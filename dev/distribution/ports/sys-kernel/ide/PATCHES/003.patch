diff -ruN linux-2.6.7/arch/i386/kernel/apm.c software-suspend-linux-2.6.7-rev10/arch/i386/kernel/apm.c
--- linux-2.6.7/arch/i386/kernel/apm.c	2004-05-19 22:10:17.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/i386/kernel/apm.c	2004-07-08 14:37:07.000000000 +1000
@@ -1414,6 +1414,8 @@
 	set_current_state(TASK_INTERRUPTIBLE);
 	for (;;) {
 		schedule_timeout(APM_CHECK_TIMEOUT);
+		if (current->flags & PF_FREEZE)
+			refrigerator(PF_FREEZE);
 		if (exit_kapmd)
 			break;
 		/*
diff -ruN linux-2.6.7/arch/i386/kernel/cpu/mcheck/non-fatal.c software-suspend-linux-2.6.7-rev10/arch/i386/kernel/cpu/mcheck/non-fatal.c
--- linux-2.6.7/arch/i386/kernel/cpu/mcheck/non-fatal.c	2004-05-19 22:10:18.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/i386/kernel/cpu/mcheck/non-fatal.c	2004-07-08 14:37:07.000000000 +1000
@@ -17,6 +17,7 @@
 #include <linux/interrupt.h>
 #include <linux/smp.h>
 #include <linux/module.h>
+#include <linux/suspend.h>
 
 #include <asm/processor.h> 
 #include <asm/system.h>
@@ -57,7 +58,10 @@
 
 static void mce_work_fn(void *data)
 { 
-	on_each_cpu(mce_checkregs, NULL, 1, 1);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (!(software_suspend_state & SOFTWARE_SUSPEND_RUNNING))
+#endif
+		on_each_cpu(mce_checkregs, NULL, 1, 1);
 	schedule_delayed_work(&mce_work, MCE_RATE);
 } 
 
diff -ruN linux-2.6.7/arch/i386/kernel/io_apic.c software-suspend-linux-2.6.7-rev10/arch/i386/kernel/io_apic.c
--- linux-2.6.7/arch/i386/kernel/io_apic.c	2004-06-18 12:43:53.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/i386/kernel/io_apic.c	2004-07-08 14:37:07.000000000 +1000
@@ -602,6 +602,8 @@
 	long time_remaining = balanced_irq_interval;
 
 	daemonize("kirqd");
+
+	current->flags |= PF_SYNCTHREAD;
 	
 	/* push everything to CPU 0 to give us a starting point.  */
 	for (i = 0 ; i < NR_IRQS ; i++) {
@@ -611,6 +613,8 @@
 repeat:
 	set_current_state(TASK_INTERRUPTIBLE);
 	time_remaining = schedule_timeout(time_remaining);
+	if (current->flags & PF_FREEZE)
+		refrigerator(PF_FREEZE);
 	if (time_after(jiffies, prev_balance_time+balanced_irq_interval)) {
 		Dprintk("balanced_irq: calling do_irq_balance() %lu\n",
 					jiffies);
diff -ruN linux-2.6.7/arch/i386/kernel/signal.c software-suspend-linux-2.6.7-rev10/arch/i386/kernel/signal.c
--- linux-2.6.7/arch/i386/kernel/signal.c	2004-06-18 12:43:53.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/i386/kernel/signal.c	2004-07-08 14:37:07.000000000 +1000
@@ -562,8 +562,10 @@
 		return 1;
 
 	if (current->flags & PF_FREEZE) {
-		refrigerator(0);
-		goto no_signal;
+		refrigerator(PF_FREEZE);
+		recalc_sigpending();
+		if (!signal_pending(current))
+			goto no_signal;
 	}
 
 	if (!oldset)
diff -ruN linux-2.6.7/arch/i386/kernel/smp.c software-suspend-linux-2.6.7-rev10/arch/i386/kernel/smp.c
--- linux-2.6.7/arch/i386/kernel/smp.c	2004-06-18 12:43:53.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/i386/kernel/smp.c	2004-07-08 14:37:07.000000000 +1000
@@ -453,7 +453,7 @@
 	preempt_enable();
 }
 
-static void do_flush_tlb_all(void* info)
+void do_flush_tlb_all(void* info)
 {
 	unsigned long cpu = smp_processor_id();
 
diff -ruN linux-2.6.7/arch/i386/mm/init.c software-suspend-linux-2.6.7-rev10/arch/i386/mm/init.c
--- linux-2.6.7/arch/i386/mm/init.c	2004-06-18 12:43:54.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/i386/mm/init.c	2004-07-08 14:37:07.000000000 +1000
@@ -27,6 +27,9 @@
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
 #include <linux/efi.h>
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+#include <linux/suspend-common.h>
+#endif
 
 #include <asm/processor.h>
 #include <asm/system.h>
@@ -247,12 +250,19 @@
 {
 	if (page_is_ram(pfn) && !(bad_ppro && page_kills_ppro(pfn))) {
 		ClearPageReserved(page);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		ClearPageNosave(page);
+#endif
 		set_bit(PG_highmem, &page->flags);
 		set_page_count(page, 1);
 		__free_page(page);
 		totalhigh_pages++;
-	} else
+	} else {
 		SetPageReserved(page);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		SetPageNosave(page);
+#endif
+	}
 }
 
 #ifndef CONFIG_DISCONTIGMEM
@@ -328,7 +338,7 @@
 #endif
 }
 
-#if defined(CONFIG_PM_DISK) || defined(CONFIG_SOFTWARE_SUSPEND)
+#if defined(CONFIG_PM_DISK) || defined(CONFIG_SOFTWARE_SUSPEND) || defined(CONFIG_SOFTWARE_SUSPEND2)
 /*
  * Swap suspend & friends need this for resume because things like the intel-agp
  * driver might have split up a kernel 4MB mapping.
@@ -469,6 +479,7 @@
 	int codesize, reservedpages, datasize, initsize;
 	int tmp;
 	int bad_ppro;
+	void * addr;
 
 #ifndef CONFIG_DISCONTIGMEM
 	if (!mem_map)
@@ -499,12 +510,29 @@
 	totalram_pages += __free_all_bootmem();
 
 	reservedpages = 0;
-	for (tmp = 0; tmp < max_low_pfn; tmp++)
-		/*
-		 * Only count reserved RAM pages
-		 */
-		if (page_is_ram(tmp) && PageReserved(pfn_to_page(tmp)))
-			reservedpages++;
+	addr = __va(0);
+	for (tmp = 0; tmp < max_low_pfn; tmp++, addr += PAGE_SIZE) {
+		if (page_is_ram(tmp)) {
+			/*
+			 * Only count reserved RAM pages
+			 */
+			if (PageReserved(mem_map+tmp))
+				reservedpages++;
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+			/*
+			 * Mark nosave pages
+			 */
+			if (addr >= (void *)&__nosave_begin && addr < (void *)&__nosave_end)
+				SetPageNosave(mem_map+tmp);
+		} else
+			/*
+			 * Non-RAM pages are always nosave
+			 */
+			SetPageNosave(mem_map+tmp);
+#else
+		}
+#endif
+	}
 
 	set_highmem_pages_init(bad_ppro);
 
@@ -603,6 +631,9 @@
 	addr = (unsigned long)(&__init_begin);
 	for (; addr < (unsigned long)(&__init_end); addr += PAGE_SIZE) {
 		ClearPageReserved(virt_to_page(addr));
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		ClearPageNosave(virt_to_page(addr));
+#endif
 		set_page_count(virt_to_page(addr), 1);
 		free_page(addr);
 		totalram_pages++;
@@ -617,6 +648,9 @@
 		printk (KERN_INFO "Freeing initrd memory: %ldk freed\n", (end - start) >> 10);
 	for (; start < end; start += PAGE_SIZE) {
 		ClearPageReserved(virt_to_page(start));
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		ClearPageNosave(virt_to_page(start));
+#endif
 		set_page_count(virt_to_page(start), 1);
 		free_page(start);
 		totalram_pages++;
diff -ruN linux-2.6.7/arch/i386/power/cpu.c software-suspend-linux-2.6.7-rev10/arch/i386/power/cpu.c
--- linux-2.6.7/arch/i386/power/cpu.c	2004-05-19 22:10:18.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/i386/power/cpu.c	2004-07-08 14:37:07.000000000 +1000
@@ -25,9 +25,11 @@
 #include <asm/uaccess.h>
 #include <asm/acpi.h>
 #include <asm/tlbflush.h>
+#include <asm/desc.h>
+#include <asm/suspend.h>
 
-static struct saved_context saved_context;
-static void fix_processor_context(void);
+struct saved_context saved_context;
+void fix_processor_context(void);
 
 unsigned long saved_context_eax, saved_context_ebx;
 unsigned long saved_context_ecx, saved_context_edx;
@@ -35,6 +37,10 @@
 unsigned long saved_context_esi, saved_context_edi;
 unsigned long saved_context_eflags;
 
+/* Special page directory for resume */
+extern char __nosavedata swsusp_pg_dir[PAGE_SIZE]
+                  __attribute__ ((aligned (PAGE_SIZE)));
+
 extern void enable_sep_cpu(void *);
 
 void save_processor_state(void)
@@ -112,7 +118,7 @@
 	do_fpu_end();
 }
 
-static void fix_processor_context(void)
+void fix_processor_context(void)
 {
 	int cpu = smp_processor_id();
 	struct tss_struct * t = init_tss + cpu;
diff -ruN linux-2.6.7/arch/i386/power/Makefile software-suspend-linux-2.6.7-rev10/arch/i386/power/Makefile
--- linux-2.6.7/arch/i386/power/Makefile	2004-01-13 14:18:39.000000000 +1100
+++ software-suspend-linux-2.6.7-rev10/arch/i386/power/Makefile	2004-07-08 14:37:07.000000000 +1000
@@ -1,3 +1,6 @@
+CFLAGS_suspend2.o = -O0
+
 obj-$(CONFIG_PM)		+= cpu.o
 obj-$(CONFIG_PM_DISK)		+= pmdisk.o
 obj-$(CONFIG_SOFTWARE_SUSPEND)	+= swsusp.o
+obj-$(CONFIG_SOFTWARE_SUSPEND2)	+= suspend2.o
diff -ruN linux-2.6.7/arch/i386/power/suspend2.c software-suspend-linux-2.6.7-rev10/arch/i386/power/suspend2.c
--- linux-2.6.7/arch/i386/power/suspend2.c	1970-01-01 10:00:00.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/i386/power/suspend2.c	2004-07-08 14:37:07.000000000 +1000
@@ -0,0 +1,656 @@
+ /*
+  * Copyright 2001-2002 Pavel Machek <pavel@suse.cz>
+  * Based on code
+  * Copyright 2001 Patrick Mochel <mochel@osdl.org>
+  */
+#include <linux/init.h>
+#include <linux/version.h>
+#include <asm/desc.h>
+#include <asm/i387.h>
+#include <asm/apic.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,99)
+#define SUSPEND_C
+#include <linux/suspend-common.h>
+extern void do_suspend2_suspend_1(void);
+extern void do_suspend2_suspend_2(void);
+extern void do_suspend2_resume_1(void);
+extern void do_suspend2_resume_2(void);
+extern struct pagedir pagedir_resume;
+extern int suspend_io_time[2][2];
+extern char __nosavedata swsusp_pg_dir[PAGE_SIZE]
+                  __attribute__ ((aligned (PAGE_SIZE)));
+#else
+#define lowmem_page_address(struct_page) (page_address(struct_page))
+char __nosavedata swsusp_pg_dir[PAGE_SIZE]
+                  __attribute__ ((aligned (PAGE_SIZE)));
+#endif
+#ifdef SUSPEND_C
+#include <asm/processor.h>
+#endif
+//#define DEBUG_LOWLEVEL_SUSPEND
+
+/* image of the saved processor states */
+struct suspend2_saved_context {
+	u32 eax, ebx, ecx, edx;
+	u32 esp, ebp, esi, edi;
+	u16 es, fs, gs, ss;
+	u32 cr0, cr2, cr3, cr4;
+	u16 gdt_pad;
+	u16 gdt_limit;
+	u32 gdt_base;
+	u16 idt_pad;
+	u16 idt_limit;
+	u32 idt_base;
+	u16 ldt;
+	u16 tss;
+	u32 tr;
+	u32 safety;
+	u32 return_address;
+	u32 eflags;
+} __attribute__((packed));
+
+#ifdef CONFIG_SMP
+static struct suspend2_saved_context suspend2_saved_contexts[NR_CPUS];
+#endif
+static struct suspend2_saved_context suspend2_saved_context;	/* temporary storage */
+
+spinlock_t saved_context_lock __nosavedata = SPIN_LOCK_UNLOCKED;
+
+#define loaddebug(thread,register) \
+               __asm__("movl %0,%%db" #register  \
+                       : /* no output */ \
+                       :"r" ((thread)->debugreg[register]))
+
+ 
+/*
+ * save_processor_context
+ * 
+ * Save the state of the processor before we go to sleep.
+ *
+ * return_stack is the value of the stack pointer (%esp) as the caller sees it.
+ * A good way could not be found to obtain it from here (don't want to make _too_
+ * many assumptions about the layout of the stack this far down.) Also, the 
+ * handy little __builtin_frame_pointer(level) where level > 0, is blatantly 
+ * buggy - it returns the value of the stack at the proper location, not the 
+ * location, like it should (as of gcc 2.91.66)
+ * 
+ * Note that the context and timing of this function is pretty critical.
+ * With a minimal amount of things going on in the caller and in here, gcc
+ * does a good job of being just a dumb compiler.  Watch the assembly output
+ * if anything changes, though, and make sure everything is going in the right
+ * place. 
+ */
+static inline void save_processor_context(void)
+{
+	kernel_fpu_begin();
+
+	/*
+	 * descriptor tables
+	 */
+	asm volatile ("sgdt (%0)" : "=m" (suspend2_saved_context.gdt_limit));
+	asm volatile ("sidt (%0)" : "=m" (suspend2_saved_context.idt_limit));
+	asm volatile ("sldt (%0)" : "=m" (suspend2_saved_context.ldt));
+	asm volatile ("str (%0)"  : "=m" (suspend2_saved_context.tr));
+
+	/*
+	 * save the general registers.
+	 * note that gcc has constructs to specify output of certain registers,
+	 * but they're not used here, because it assumes that you want to modify
+	 * those registers, so it tries to be smart and save them beforehand.
+	 * It's really not necessary, and kinda fishy (check the assembly output),
+	 * so it's avoided. 
+	 */
+	asm volatile ("movl %%esp, (%0)" : "=m" (suspend2_saved_context.esp));
+	asm volatile ("movl %%eax, (%0)" : "=m" (suspend2_saved_context.eax));
+	asm volatile ("movl %%ebx, (%0)" : "=m" (suspend2_saved_context.ebx));
+	asm volatile ("movl %%ecx, (%0)" : "=m" (suspend2_saved_context.ecx));
+	asm volatile ("movl %%edx, (%0)" : "=m" (suspend2_saved_context.edx));
+	asm volatile ("movl %%ebp, (%0)" : "=m" (suspend2_saved_context.ebp));
+	asm volatile ("movl %%esi, (%0)" : "=m" (suspend2_saved_context.esi));
+	asm volatile ("movl %%edi, (%0)" : "=m" (suspend2_saved_context.edi));
+
+	/*
+	 * segment registers
+	 */
+	asm volatile ("movw %%es, %0" : "=r" (suspend2_saved_context.es));
+	asm volatile ("movw %%fs, %0" : "=r" (suspend2_saved_context.fs));
+	asm volatile ("movw %%gs, %0" : "=r" (suspend2_saved_context.gs));
+	asm volatile ("movw %%ss, %0" : "=r" (suspend2_saved_context.ss));
+
+	/*
+	 * control registers 
+	 */
+	asm volatile ("movl %%cr0, %0" : "=r" (suspend2_saved_context.cr0));
+	asm volatile ("movl %%cr2, %0" : "=r" (suspend2_saved_context.cr2));
+	asm volatile ("movl %%cr3, %0" : "=r" (suspend2_saved_context.cr3));
+	asm volatile ("movl %%cr4, %0" : "=r" (suspend2_saved_context.cr4));
+
+	/*
+	 * eflags
+	 */
+	asm volatile ("pushfl ; popl (%0)" : "=m" (suspend2_saved_context.eflags));
+}
+
+static void fix_processor_context(void)
+{
+	int nr = smp_processor_id();
+	struct tss_struct * t = &init_tss[nr];
+
+	set_tss_desc(nr,t);	/* This just modifies memory; should not be neccessary. But... This is neccessary, because 386 hardware has concept of busy tsc or some similar stupidity. */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,99)
+        cpu_gdt_table[nr][GDT_ENTRY_TSS].b &= 0xfffffdff;
+
+	load_TR_desc();
+#else
+        gdt_table[__TSS(nr)].b &= 0xfffffdff;
+
+	load_TR(nr);		/* This does ltr */
+#endif
+
+	load_LDT(&current->active_mm->context);	/* This does lldt */
+
+	/*
+	 * Now maybe reload the debug registers
+	 */
+	if (current->thread.debugreg[7]){
+                loaddebug(&current->thread, 0);
+                loaddebug(&current->thread, 1);
+                loaddebug(&current->thread, 2);
+                loaddebug(&current->thread, 3);
+                /* no 4 and 5 */
+                loaddebug(&current->thread, 6);
+                loaddebug(&current->thread, 7);
+	}
+
+}
+
+static void do_fpu_end(void)
+{
+        /* restore FPU regs if necessary */
+	/* Do it out of line so that gcc does not move cr0 load to some stupid place */
+        kernel_fpu_end();
+}
+
+/*
+ * restore_processor_context
+ * 
+ * Restore the processor context as it was before we went to sleep
+ * - descriptor tables
+ * - control registers
+ * - segment registers
+ * - flags
+ * 
+ * Note that it is critical that this function is declared inline.  
+ * It was separated out from restore_state to make that function
+ * a little clearer, but it needs to be inlined because we won't have a
+ * stack when we get here (so we can't push a return address).
+ */
+static inline void restore_processor_context(void)
+{
+	/*
+	 * first restore %ds, so we can access our data properly
+	 */
+	asm volatile (".align 4");
+	asm volatile ("movw %0, %%ds" :: "r" ((u16)__KERNEL_DS));
+
+
+	/*
+	 * control registers
+	 */
+	asm volatile ("movl %0, %%cr4" :: "r" (suspend2_saved_context.cr4));
+	asm volatile ("movl %0, %%cr3" :: "r" (suspend2_saved_context.cr3));
+	asm volatile ("movl %0, %%cr2" :: "r" (suspend2_saved_context.cr2));
+	asm volatile ("movl %0, %%cr0" :: "r" (suspend2_saved_context.cr0));
+
+	/*
+	 * segment registers
+	 */
+	asm volatile ("movw %0, %%es" :: "r" (suspend2_saved_context.es));
+	asm volatile ("movw %0, %%fs" :: "r" (suspend2_saved_context.fs));
+	asm volatile ("movw %0, %%gs" :: "r" (suspend2_saved_context.gs));
+	asm volatile ("movw %0, %%ss" :: "r" (suspend2_saved_context.ss));
+
+	/*
+	 * the other general registers
+	 *
+	 * note that even though gcc has constructs to specify memory 
+	 * input into certain registers, it will try to be too smart
+	 * and save them at the beginning of the function.  This is esp.
+	 * bad since we don't have a stack set up when we enter, and we 
+	 * want to preserve the values on exit. So, we set them manually.
+	 */
+	asm volatile ("movl %0, %%esp" :: "m" (suspend2_saved_context.esp));
+	asm volatile ("movl %0, %%ebp" :: "m" (suspend2_saved_context.ebp));
+	asm volatile ("movl %0, %%eax" :: "m" (suspend2_saved_context.eax));
+	asm volatile ("movl %0, %%ebx" :: "m" (suspend2_saved_context.ebx));
+	asm volatile ("movl %0, %%ecx" :: "m" (suspend2_saved_context.ecx));
+	asm volatile ("movl %0, %%edx" :: "m" (suspend2_saved_context.edx));
+	asm volatile ("movl %0, %%esi" :: "m" (suspend2_saved_context.esi));
+	asm volatile ("movl %0, %%edi" :: "m" (suspend2_saved_context.edi));
+
+	/*
+	 * now restore the descriptor tables to their proper values
+	 * ltr is done i fix_processor_context().
+	 */
+
+	asm volatile ("lgdt (%0)" :: "m" (suspend2_saved_context.gdt_limit));
+	asm volatile ("lidt (%0)" :: "m" (suspend2_saved_context.idt_limit));
+	asm volatile ("lldt (%0)" :: "m" (suspend2_saved_context.ldt));
+
+	fix_processor_context();
+
+	/*
+	 * the flags
+	 */
+	asm volatile ("pushl %0 ; popfl" :: "m" (suspend2_saved_context.eflags));
+
+	do_fpu_end();
+}
+
+#ifdef SUSPEND_C
+/* Local variables for do_suspend2_lowlevel */
+volatile static int loop __nosavedata = 0;
+volatile static int state1 __nosavedata = 0;
+volatile static int state2 __nosavedata = 0;
+volatile static int state3 __nosavedata = 0;
+volatile static struct range *origrange __nosavedata;
+volatile static struct range *copyrange __nosavedata;
+volatile static int origoffset __nosavedata;
+volatile static int copyoffset __nosavedata;
+volatile static unsigned long * origpage __nosavedata;
+volatile static unsigned long * copypage __nosavedata;
+volatile unsigned char * my_saved_context __nosavedata;
+static int io_speed_save[2][2] __nosavedata;
+#ifndef CONFIG_SMP
+static unsigned long c_loops_per_jiffy_ref __nosavedata = 0;
+static unsigned long cpu_khz_ref __nosavedata = 0;
+#endif
+extern atomic_t suspend_cpu_counter __nosavedata;
+
+/* 
+ * APIC support: These routines save the APIC
+ * configuration for the CPU on which they are
+ * being executed
+ */
+extern void suspend_apic_save_state(void);
+extern void suspend_apic_reload_state(void);
+
+#ifdef CONFIG_SMP
+/* ------------------------------------------------
+ * BEGIN Irq affinity code, based on code from LKCD.
+ *
+ * IRQ affinity support:
+ * Save and restore IRQ affinities, and set them
+ * all to CPU 0.
+ *
+ * Section between dashes taken from LKCD code.
+ * Perhaps we should be working toward a shared library
+ * of such routines for kexec, lkcd, software suspend
+ * and whatever other similar projects there are?
+ */
+
+extern irq_desc_t irq_desc[];
+extern unsigned long irq_affinity[];
+unsigned long saved_affinity[NR_IRQS];
+
+/*
+ * Routine to save the old irq affinities and change affinities of all irqs to
+ * the dumping cpu.
+ */
+static void set_irq_affinity(void)
+{
+	int i;
+	int cpu = smp_processor_id();
+
+	memcpy(saved_affinity, irq_affinity, NR_IRQS * sizeof(unsigned long));
+	for (i = 0; i < NR_IRQS; i++) {
+		if (irq_desc[i].handler == NULL)
+			continue;
+		irq_affinity[i] = 1UL << cpu;
+		if (irq_desc[i].handler->set_affinity != NULL)
+			irq_desc[i].handler->set_affinity(i, irq_affinity[i]);
+	}
+}
+
+/*
+ * Restore old irq affinities.
+ */
+static void reset_irq_affinity(void)
+{
+	int i;
+
+	memcpy(irq_affinity, saved_affinity, NR_IRQS * sizeof(unsigned long));
+	for (i = 0; i < NR_IRQS; i++) {
+		if (irq_desc[i].handler == NULL)
+			continue;
+		if (irq_desc[i].handler->set_affinity != NULL)
+			irq_desc[i].handler->set_affinity(i, saved_affinity[i]);
+	}
+}
+
+/*
+ * END of IRQ affinity code, based on LKCD code.
+ * -----------------------------------------------------------------
+ */
+#endif
+
+/*
+ * FIXME: This function should really be written in assembly. Actually
+ * requirement is that it does not touch stack, because %esp will be
+ * wrong during resume before restore_processor_context(). Check
+ * assembly if you modify this.
+ *
+ * SMP support:
+ * All SMP processors enter this routine during suspend. The one through
+ * which the suspend is initiated (which, for simplicity, is always CPU 0)
+ * sends the others here using an IPI during do_suspend2_suspend_1. They
+ * remain here until after the atomic copy of the kernel is made, to ensure
+ * that they don't mess with memory in the meantime (even just idling will
+ * do that). Once the atomic copy is made, they are free to carry on idling.
+ * Note that we must let them go, because if we're using compression, the
+ * vfree calls in the compressors will result in IPIs being called and hanging
+ * because the CPUs are still here.
+ *
+ * At resume time, we do a similar thing. CPU 0 sends the others in here using
+ * an IPI. It then copies the original kernel back, restores its own processor
+ * context and flushes local tlbs before freeing the others to do the same.
+ * They can then go back to idling while CPU 0 reloads pageset 2, cleans up
+ * and unfreezes the processes.
+ *
+ * (Remember that freezing and thawing processes also uses IPIs, as may
+ * decompressing the data. Again, therefore, we cannot leave the other processors
+ * in here).
+ * 
+ * At the moment, we do nothing about APICs, even though the code is there.
+ */
+void do_suspend2_lowlevel(int resume)
+{
+	if (!resume) {
+#ifdef CONFIG_SMP
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+		if (smp_processor_id() != cpu_logical_map(0)) {
+#else
+		if (smp_processor_id()) {
+#endif
+			/* 
+			 *Save context and go back to idling.
+			 * Note that we cannot leave the processor
+			 * here. It must be able to receive IPIs if
+			 * the LZF compression driver (eg) does a
+			 * vfree after compressing the kernel etc
+			 */
+			while ((software_suspend_state & SOFTWARE_SUSPEND_FREEZE_SMP) &&
+				(atomic_read(&suspend_cpu_counter) != (smp_processor_id() - 1))) {
+				smp_mb();
+				barrier();
+			}
+			save_processor_context();
+			my_saved_context = (unsigned char *) (suspend2_saved_contexts + smp_processor_id());
+			for (loop = sizeof(struct suspend2_saved_context); loop--; loop)
+				*(my_saved_context + loop - 1) = *(((unsigned char *) &suspend2_saved_context) + loop - 1);
+#ifdef DEBUG_LOWLEVEL_SUSPEND
+			printk("Saved context:\n");
+			for (loop = 0; loop < sizeof(struct suspend2_saved_context); loop+=(sizeof(unsigned long))) {
+				if (!(loop%16))
+					printk("%p: ", ((unsigned char *) &suspend2_saved_context) + loop);
+				printk("%lx %s", 
+					*((unsigned long *) (((unsigned char *) &suspend2_saved_context) + loop)),
+					(!((loop + 4)%16)) ? "\n" : "");
+			}
+			printk("\nMy Saved context:\n");
+			for (loop = 0; loop < sizeof(struct suspend2_saved_context); loop+=4) {
+				if (!(loop%16))
+					printk("%p: ", my_saved_context + loop);
+				printk("%lx %s",
+					*((unsigned long *) (my_saved_context + loop)),
+					(!((loop + 4)%16)) ? "\n" : "");
+			}
+			printk("\n");
+#endif
+			atomic_inc(&suspend_cpu_counter);
+			/* Now spin until the atomic copy of the kernel is made. */
+			while (software_suspend_state & SOFTWARE_SUSPEND_FREEZE_SMP) {
+				cpu_relax();
+				smp_mb();
+			}
+			FLUSH_LOCAL_TLB();
+			atomic_dec(&suspend_cpu_counter);
+			return;
+		}
+
+		/*
+		 * Save the irq affinities before we freeze the
+		 * other processors!
+		 */
+		set_irq_affinity();
+#endif
+
+		do_suspend2_suspend_1();
+		save_processor_context();	/* We need to capture registers and memory at "same time" */
+		do_suspend2_suspend_2();		/* If everything goes okay, this function does not return */
+		return;
+	}
+
+	/* We want to run from swsusp_pg_dir, since swsusp_pg_dir is stored in constant
+	 * place in memory 
+	 */
+
+        __asm__( "movl %%ecx,%%cr3\n" ::"c"(__pa(swsusp_pg_dir)));
+
+/*
+ * Final function for resuming: after copying the pages to their original
+ * position, it restores the register state.
+ *
+ * What about page tables? Writing data pages may toggle
+ * accessed/dirty bits in our page tables. That should be no problems
+ * with 4MB page tables. That's why we require have_pse.  
+ *
+ * This loops destroys stack from under itself, so it better should
+ * not use any stack space, itself. When this function is entered at
+ * resume time, we move stack to _old_ place.  This is means that this
+ * function must use no stack and no local variables in registers,
+ * until calling restore_processor_context();
+ *
+ * Critical section here: noone should touch saved memory after
+ * do_suspend2_resume_1; copying works, because nr_copy_pages,
+ * pagedir_resume, loop and loop2 are nosavedata.
+ */
+
+#ifdef CONFIG_PREEMPT
+	/*
+	 * Preempt disabled in kernel we're about to restore.
+	 * Make sure we match state now.
+	 */
+	preempt_disable();
+#endif
+
+#ifdef CONFIG_SMP
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	if (smp_processor_id() != cpu_logical_map(0)) {
+#else
+	if (smp_processor_id()) {
+#endif
+		/* Save context and hold other processors here */
+		atomic_inc(&suspend_cpu_counter);
+		smp_mb();
+		barrier();
+		while ((software_suspend_state & SOFTWARE_SUSPEND_FREEZE_SMP) ||
+			(atomic_read(&suspend_cpu_counter) != smp_processor_id())) {
+			cpu_relax();
+			smp_mb();
+		}
+	       	my_saved_context = (unsigned char *) (suspend2_saved_contexts + smp_processor_id());
+		//KDB_ENTER();
+		for (loop = sizeof(struct suspend2_saved_context); loop--; loop)
+			*(((unsigned char *) &suspend2_saved_context) + loop - 1) = *(my_saved_context + loop - 1);
+		restore_processor_context();
+		FLUSH_LOCAL_TLB();
+		atomic_dec(&suspend_cpu_counter);
+		return;
+	}
+#endif
+
+	do_suspend2_resume_1();
+
+	state1 = suspend_action;
+	state2 = suspend_debug_state;
+	state3 = console_loglevel;
+	for (loop = 0; loop < 4; loop++)
+		io_speed_save[loop/2][loop%2] = 
+			suspend_io_time[loop/2][loop%2];
+
+#ifdef CONFIG_SMP
+	/* Send all IRQs to CPU 0. We will replace the saved affinities
+	 * with the suspend-time ones when we copy the original kernel
+	 * back in place
+	 */
+	set_irq_affinity();
+#else
+	c_loops_per_jiffy_ref = cpu_data->loops_per_jiffy;
+	cpu_khz_ref = cpu_khz;
+#endif
+	
+	origrange = pagedir_resume.origranges.first;
+	copyrange = pagedir_resume.destranges.first;
+	origoffset = origrange->minimum;
+	copyoffset = copyrange->minimum;
+	origpage = (unsigned long *) (lowmem_page_address(mem_map + origoffset));
+	copypage = (unsigned long *) (lowmem_page_address(mem_map + copyoffset));
+
+	/* As of 2.0.0.51, pageset1 can include highmem pages. If
+	 * !CONFIG_HIGHMEM, highstart_pfn == 0, hence the #ifdef.
+	 */
+#ifdef CONFIG_HIGHMEM
+	while ((origrange) && (origoffset < highstart_pfn)) {
+#else
+	while (origrange) {
+#endif
+		for (loop=0; loop < (PAGE_SIZE / sizeof(unsigned long)); loop++)
+			*(origpage + loop) = *(copypage + loop);
+		
+		if (origoffset < origrange->maximum) {
+			origoffset++;
+			origpage += (PAGE_SIZE / sizeof(unsigned long));
+		} else {
+			origrange = origrange->next;
+			if (origrange) {
+				origoffset = origrange->minimum;
+				origpage = (unsigned long *) (lowmem_page_address(mem_map + origoffset));
+			}
+		}
+
+		if (copyoffset < copyrange->maximum) {
+			copyoffset++;
+			copypage += (PAGE_SIZE / sizeof(unsigned long));
+		} else {
+			copyrange = copyrange->next;
+			if (copyrange) {
+				copyoffset = copyrange->minimum;
+				copypage = (unsigned long *) (lowmem_page_address(mem_map + copyoffset));
+			}
+		}
+	}
+	
+	restore_processor_context();
+#ifdef CONFIG_SMP
+	FLUSH_LOCAL_TLB();
+#else
+	__flush_tlb_all();
+#endif
+	
+	/* Now we are running with our old stack, and with registers copied
+	 * from suspend time. Let's copy back those remaining Highmem pages. */
+
+#ifdef CONFIG_HIGHMEM
+	while (origrange) {
+		unsigned long * origpage = (unsigned long *) KMAP_ATOMIC(mem_map + origoffset);
+		for (loop=0; loop < (PAGE_SIZE / sizeof(unsigned long)); loop++)
+			*(origpage + loop) = *(copypage + loop);
+		KUNMAP_ATOMIC(mem_map + origoffset);
+		
+		if (origoffset < origrange->maximum)
+			origoffset++;
+		else {
+			origrange = origrange->next;
+			if (origrange)
+				origoffset = origrange->minimum;
+		}
+
+		if (copyoffset < copyrange->maximum) {
+			copyoffset++;
+			copypage += (PAGE_SIZE / sizeof(unsigned long));
+		} else {
+			copyrange = copyrange->next;
+			if (copyrange) {
+				copyoffset = copyrange->minimum;
+				copypage = (unsigned long *) (page_address(mem_map + copyoffset));
+			}
+		}
+	}
+#endif
+
+#if defined(DEBUG_LOWLEVEL_SUSPEND) && #defined(CONFIG_SMP)
+	{
+		my_saved_context = (unsigned char *) (suspend2_saved_contexts + 1);
+		printk("Saved context for CPU 1:\n");
+		for (loop = 0; loop < sizeof(struct suspend2_saved_context); loop+=4) {
+			if (!(loop%16))
+				printk("%p: ", my_saved_context + loop);
+			printk("%lx %s",
+				*((unsigned long *) (my_saved_context + loop)),
+				(!((loop + 4)%16)) ? "\n" : "");
+		}
+	}
+#endif
+	/* Get other CPUs to restore their contexts and flush their tlbs. */
+	software_suspend_state &= ~SOFTWARE_SUSPEND_FREEZE_SMP;
+	
+	while (atomic_read(&suspend_cpu_counter)) {
+		cpu_relax();
+		smp_mb();
+	}
+
+#ifdef CONFIG_SMP
+	/* put the irq affinity tables back */
+	reset_irq_affinity();
+#else
+	cpu_data->loops_per_jiffy = c_loops_per_jiffy_ref;
+	loops_per_jiffy = c_loops_per_jiffy_ref;
+	cpu_khz = cpu_khz_ref;
+#endif
+	suspend_action = state1;
+	suspend_debug_state = state2;
+	console_loglevel = state3;
+
+	for (loop = 0; loop < 4; loop++)
+		suspend_io_time[loop/2][loop%2] =
+			io_speed_save[loop/2][loop%2];
+
+	do_suspend2_resume_2();
+#ifdef DEBUG_LOWLEVEL_SUSPEND
+	printk("CPU %d left lowlevel suspend.\n", smp_processor_id());
+#endif
+}
+
+/*
+ * Function to put other smp processors in do_suspend2_lowlevel
+ * during suspend or resume. They get their CPU data saved and
+ * restored there
+ */
+
+void smp_suspend2_lowlevel(void * info)
+{
+	unsigned long irq_lock_flags;
+	spinlock_t irq_lock = SPIN_LOCK_UNLOCKED;
+
+	smp_mb();
+	barrier();
+	spin_lock_irqsave(&irq_lock, irq_lock_flags);
+	kernel_fpu_begin();
+	do_suspend2_lowlevel(now_resuming);
+	barrier();
+	smp_mb();
+	kernel_fpu_end();
+	spin_unlock_irqrestore(&irq_lock, irq_lock_flags);
+}
+#endif 
diff -ruN linux-2.6.7/arch/ppc/Kconfig software-suspend-linux-2.6.7-rev10/arch/ppc/Kconfig
--- linux-2.6.7/arch/ppc/Kconfig	2004-06-18 12:43:55.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/ppc/Kconfig	2004-07-08 14:37:07.000000000 +1000
@@ -197,6 +197,8 @@
 
 	  If in doubt, say Y here.
 
+source kernel/power/Kconfig
+
 source arch/ppc/platforms/4xx/Kconfig
 
 config PPC64BRIDGE
diff -ruN linux-2.6.7/arch/ppc/kernel/signal.c software-suspend-linux-2.6.7-rev10/arch/ppc/kernel/signal.c
--- linux-2.6.7/arch/ppc/kernel/signal.c	2004-05-19 22:10:21.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/ppc/kernel/signal.c	2004-07-08 14:37:07.000000000 +1000
@@ -28,6 +28,7 @@
 #include <linux/elf.h>
 #include <linux/tty.h>
 #include <linux/binfmts.h>
+#include <linux/suspend.h>
 #include <asm/ucontext.h>
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -569,6 +570,15 @@
 	unsigned long frame, newsp;
 	int signr, ret;
 
+	if (current->flags & PF_FREEZE) {
+		refrigerator(PF_FREEZE);
+		signr = 0;
+		ret = regs->gpr[3];
+		recalc_sigpending();
+		if (!signal_pending(current))
+			goto no_signal;
+	}
+
 	if (!oldset)
 		oldset = &current->blocked;
 
@@ -593,6 +603,7 @@
 			regs->gpr[3] = EINTR;
 			/* note that the cr0.SO bit is already set */
 		} else {
+no_signal:
 			regs->nip -= 4;	/* Back up & retry system call */
 			regs->result = 0;
 			regs->trap = 0;
diff -ruN linux-2.6.7/arch/ppc/kernel/vmlinux.lds.S software-suspend-linux-2.6.7-rev10/arch/ppc/kernel/vmlinux.lds.S
--- linux-2.6.7/arch/ppc/kernel/vmlinux.lds.S	2004-05-19 22:10:21.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/ppc/kernel/vmlinux.lds.S	2004-07-08 14:37:07.000000000 +1000
@@ -73,6 +73,12 @@
     CONSTRUCTORS
   }
 
+  . = ALIGN(4096);
+  __nosave_begin = .;
+  .data_nosave : { *(.data.nosave) }
+  . = ALIGN(4096);
+  __nosave_end = .;
+
   . = ALIGN(32);
   .data.cacheline_aligned : { *(.data.cacheline_aligned) }
 
diff -ruN linux-2.6.7/arch/ppc/Makefile software-suspend-linux-2.6.7-rev10/arch/ppc/Makefile
--- linux-2.6.7/arch/ppc/Makefile	2004-06-18 12:43:55.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/ppc/Makefile	2004-07-08 14:37:07.000000000 +1000
@@ -43,6 +43,7 @@
 drivers-$(CONFIG_8xx)		+= arch/ppc/8xx_io/
 drivers-$(CONFIG_4xx)		+= arch/ppc/4xx_io/
 drivers-$(CONFIG_8260)		+= arch/ppc/8260_io/
+drivers-$(CONFIG_PM)		+= arch/ppc/power/
 
 BOOT_TARGETS = zImage zImage.initrd znetboot znetboot.initrd vmlinux.sm
 
diff -ruN linux-2.6.7/arch/ppc/mm/init.c software-suspend-linux-2.6.7-rev10/arch/ppc/mm/init.c
--- linux-2.6.7/arch/ppc/mm/init.c	2004-06-18 12:43:56.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/ppc/mm/init.c	2004-07-08 14:37:07.000000000 +1000
@@ -31,6 +31,9 @@
 #include <linux/bootmem.h>
 #include <linux/highmem.h>
 #include <linux/initrd.h>
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+#include <linux/suspend-common.h>
+#endif
 
 #include <asm/pgalloc.h>
 #include <asm/prom.h>
@@ -148,6 +151,9 @@
 
 	while (start < end) {
 		ClearPageReserved(virt_to_page(start));
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		ClearPageNosave(virt_to_page(start));
+#endif
 		set_page_count(virt_to_page(start), 1);
 		free_page(start);
 		cnt++;
@@ -187,6 +193,9 @@
 
 	for (; start < end; start += PAGE_SIZE) {
 		ClearPageReserved(virt_to_page(start));
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		ClearPageNosave(virt_to_page(start));
+#endif
 		set_page_count(virt_to_page(start), 1);
 		free_page(start);
 		totalram_pages++;
@@ -413,8 +422,12 @@
 	/* if we are booted from BootX with an initial ramdisk,
 	   make sure the ramdisk pages aren't reserved. */
 	if (initrd_start) {
-		for (addr = initrd_start; addr < initrd_end; addr += PAGE_SIZE)
+		for (addr = initrd_start; addr < initrd_end; addr += PAGE_SIZE) {
 			ClearPageReserved(virt_to_page(addr));
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+			ClearPageNosave(virt_to_page(addr));
+#endif
+		}
 	}
 #endif /* CONFIG_BLK_DEV_INITRD */
 
@@ -440,6 +453,14 @@
 	     addr += PAGE_SIZE) {
 		if (!PageReserved(virt_to_page(addr)))
 			continue;
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		/*
+		 * Mark nosave pages
+		 */
+		if (addr >= (void *)&__nosave_begin && addr < (void *)&__nosave_end)
+			SetPageNosave(virt_to_page(addr));
+#endif
+
 		if (addr < (ulong) etext)
 			codepages++;
 		else if (addr >= (unsigned long)&__init_begin
@@ -457,6 +478,9 @@
 			struct page *page = mem_map + pfn;
 
 			ClearPageReserved(page);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+			ClearPageNosave(page);
+#endif
 			set_bit(PG_highmem, &page->flags);
 			set_page_count(page, 1);
 			__free_page(page);
@@ -490,7 +514,6 @@
 			pg->index = addr;
 		}
 	}
-
 	mem_init_done = 1;
 }
 
diff -ruN linux-2.6.7/arch/ppc/platforms/pmac_feature.c software-suspend-linux-2.6.7-rev10/arch/ppc/platforms/pmac_feature.c
--- linux-2.6.7/arch/ppc/platforms/pmac_feature.c	2004-06-18 12:43:56.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/ppc/platforms/pmac_feature.c	2004-07-08 14:37:07.000000000 +1000
@@ -2118,7 +2118,10 @@
 	},
 	{	"PowerBook6,1",			"PowerBook G4 12\"",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
-		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
+#ifdef CONFIG_SOFTWARE_REPLACE_SLEEP
+		| PMAC_MB_CAN_SLEEP,
+#endif
 	},
 	{	"PowerBook6,2",			"PowerBook G4",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
diff -ruN linux-2.6.7/arch/ppc/power/cpu.c software-suspend-linux-2.6.7-rev10/arch/ppc/power/cpu.c
--- linux-2.6.7/arch/ppc/power/cpu.c	1970-01-01 10:00:00.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/ppc/power/cpu.c	2004-07-08 14:37:07.000000000 +1000
@@ -0,0 +1,61 @@
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/string.h>
+#include <linux/adb.h>
+#include <linux/cuda.h>
+#include <linux/pmu.h>
+#include <linux/suspend.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+
+#include <asm/mmu_context.h>
+
+extern void enable_kernel_altivec(void);
+
+static inline void do_pmu_resume(void)
+{
+	struct adb_request req;
+
+	printk("resume pmu");	
+	/* Tell PMU we are ready */
+	pmu_request(&req, NULL, 2, PMU_SYSTEM_READY, 2);
+	pmu_wait_complete(&req);
+
+	/* Resume PMU event interrupts */
+	pmu_resume();	
+	printk(".\n");
+}
+
+void save_processor_state(void)
+{
+	printk("suspend pmu");	
+	pmu_suspend();
+	printk(".\n");
+	printk("current is 0x%p\n", current);
+}
+
+void restore_processor_state(void)
+{
+	printk("seting context, 0x%p", current);
+	local_irq_disable();
+	/* Restore userland MMU context */
+	set_context(current->active_mm->context, current->active_mm->pgd);
+	printk(".\n");
+
+#ifdef CONFIG_ALTIVEC
+	if (cur_cpu_spec[0]->cpu_features & CPU_FTR_ALTIVEC)
+		enable_kernel_altivec();
+#endif
+	printk("enable kernel fp");
+	enable_kernel_fp();
+	printk(".\n");
+	do_pmu_resume();
+	local_irq_enable();
+}
+
+EXPORT_SYMBOL(save_processor_state);
+EXPORT_SYMBOL(restore_processor_state);
diff -ruN linux-2.6.7/arch/ppc/power/cpu_reg.S software-suspend-linux-2.6.7-rev10/arch/ppc/power/cpu_reg.S
--- linux-2.6.7/arch/ppc/power/cpu_reg.S	1970-01-01 10:00:00.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/ppc/power/cpu_reg.S	2004-07-08 14:37:07.000000000 +1000
@@ -0,0 +1,325 @@
+/*
+ * This code base on pmdisk.S by Benjamin Herrenschmidt <benh@kernel.crashing.org>
+ *
+ * changed for swsusp2 by Hu Gang <hugang@soulinfo.com>
+ */
+#include <linux/config.h>
+#include <linux/threads.h>
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/cputable.h>
+#include <asm/thread_info.h>
+#include <asm/ppc_asm.h>
+#include <asm/offsets.h>
+
+/*
+ * Structure for storing CPU registers on the save area.
+ */
+#define SL_SP		0
+#define SL_PC		4
+#define SL_MSR		8
+#define SL_SDR1		0xc
+#define SL_SPRG0	0x10	/* 4 sprg's */
+#define SL_DBAT0	0x20
+#define SL_IBAT0	0x28
+#define SL_DBAT1	0x30
+#define SL_IBAT1	0x38
+#define SL_DBAT2	0x40
+#define SL_IBAT2	0x48
+#define SL_DBAT3	0x50
+#define SL_IBAT3	0x58
+#define SL_TB		0x60
+#define SL_R2		0x68
+#define SL_CR		0x6c
+#define SL_LR		0x70
+#define SL_R12		0x74	/* r12 to r31 */
+#define SL_SIZE		(SL_R12 + 80)
+
+#define CPU_REG_MEM_DEFINE \
+	.section .data					  ; \
+	.align	5					  ; \
+\
+_GLOBAL(cpu_reg_save_area)				  ; \
+	.space	SL_SIZE	
+	
+#define CPU_REG_MEM_SAVE \
+	lis	r11,cpu_reg_save_area@h;\
+	ori	r11,r11,cpu_reg_save_area@l;\
+;\
+	mflr	r0					  ; \
+	stw	r0,SL_LR(r11);\
+	mfcr	r0;\
+	stw	r0,SL_CR(r11);\
+	stw	r1,SL_SP(r11);\
+	stw	r2,SL_R2(r11);\
+	stmw	r12,SL_R12(r11);\
+;\
+	/* Save MSR & SDR1 */;\
+	mfmsr	r4;\
+	stw	r4,SL_MSR(r11);\
+	mfsdr1	r4;\
+	stw	r4,SL_SDR1(r11);\
+;\
+	/* Get a stable timebase and save it */;\
+1:	mftbu	r4;\
+	stw	r4,SL_TB(r11);\
+	mftb	r5;\
+	stw	r5,SL_TB+4(r11);\
+	mftbu	r3;\
+	cmpw	r3,r4;\
+	bne	1b;\
+;\
+	/* Save SPRGs */;\
+	mfsprg	r4,0;\
+	stw	r4,SL_SPRG0(r11);\
+	mfsprg	r4,1;\
+	stw	r4,SL_SPRG0+4(r11);\
+	mfsprg	r4,2;\
+	stw	r4,SL_SPRG0+8(r11);\
+	mfsprg	r4,3;\
+	stw	r4,SL_SPRG0+12(r11);\
+;\
+	/* Save BATs */;\
+	mfdbatu	r4,0;\
+	stw	r4,SL_DBAT0(r11);\
+	mfdbatl	r4,0;\
+	stw	r4,SL_DBAT0+4(r11);\
+	mfdbatu	r4,1;\
+	stw	r4,SL_DBAT1(r11);\
+	mfdbatl	r4,1;\
+	stw	r4,SL_DBAT1+4(r11);\
+	mfdbatu	r4,2;\
+	stw	r4,SL_DBAT2(r11);\
+	mfdbatl	r4,2;\
+	stw	r4,SL_DBAT2+4(r11);\
+	mfdbatu	r4,3;\
+	stw	r4,SL_DBAT3(r11);\
+	mfdbatl	r4,3;\
+	stw	r4,SL_DBAT3+4(r11);\
+	mfibatu	r4,0;\
+	stw	r4,SL_IBAT0(r11);\
+	mfibatl	r4,0;\
+	stw	r4,SL_IBAT0+4(r11);\
+	mfibatu	r4,1;\
+	stw	r4,SL_IBAT1(r11);\
+	mfibatl	r4,1;\
+	stw	r4,SL_IBAT1+4(r11);\
+	mfibatu	r4,2;\
+	stw	r4,SL_IBAT2(r11);\
+	mfibatl	r4,2;\
+	stw	r4,SL_IBAT2+4(r11);\
+	mfibatu	r4,3;\
+	stw	r4,SL_IBAT3(r11);\
+	mfibatl	r4,3;\
+	stw	r4,SL_IBAT3+4(r11);\
+	/* Backup various CPU config stuffs */;\
+	/* bl	__save_cpu_setup; */
+
+#define CPU_REG_MEM_DISABLE_MMU \
+	/* Disable MSR:DR to make sure we don't take a TLB or	;\
+	 * hash miss during the copy, as our hash table will	;\
+	 * for a while be unuseable. For .text, we assume we are;\
+	 * covered by a BAT. This works only for non-G5 at this	;\
+	 * point. G5 will need a better approach, possibly using;\
+	 * a small temporary hash table filled with large mappings,;\
+	 * disabling the MMU completely isn't a good option for	;\
+	 * performance reasons.	;\
+	 * (Note that 750's may have the same performance issue as;\
+	 * the G5 in this case, we should investigate using moving;\
+	 * BATs for these CPUs);\
+	 */;\
+	mfmsr	r0	;\
+	sync	;\
+	rlwinm	r0,r0,0,28,26		/* clear MSR_DR */ ;\
+	mtmsr	r0 ;\
+	sync ;\
+	isync
+
+#define CPU_REG_MEM_FLUSH_CACHE \
+	/* Do a very simple cache flush/inval of the L1 to ensure \
+	 * coherency of the icache \
+	 */ \
+	lis	r3,0x0002 ;\
+	mtctr	r3 ;\
+	li	r3, 0 ;\
+1: ;\
+	lwz	r0,0(r3) ;\
+	addi	r3,r3,0x0020 ;\
+	bdnz	1b ;\
+	isync ;\
+	sync ;\
+;\
+	/* Now flush those cache lines */ ;\
+	lis	r3,0x0002 ;\
+	mtctr	r3 ;\
+	li	r3, 0 ;\
+1:;\
+	dcbf	0,r3 ;\
+	addi	r3,r3,0x0020 ;\
+	bdnz	1b
+
+#define CPU_REG_MEM_RESTORE \
+/* Ok, we are now running with the kernel data of the old;\
+	 * kernel fully restored. We can get to the save area;\
+	 * easily now. As for the rest of the code, it assumes the;\
+	 * loader kernel and the booted one are exactly identical;\
+	 */;\
+	lis	r11,cpu_reg_save_area@h;\
+	ori	r11,r11,cpu_reg_save_area@l;\
+	tophys(r11,r11);\
+	/* Restore various CPU config stuffs */;\
+	/* bl	__restore_cpu_setup; */\
+	/* Restore the BATs, and SDR1.  Then we can turn on the MMU. ;\
+	 * This is a bit hairy as we are running out of those BATs,;\
+	 * but first, our code is probably in the icache, and we are;\
+	 * writing the same value to the BAT, so that should be fine,;\
+	 * though a better solution will have to be found long-term;\
+	 */;\
+	lwz	r4,SL_SDR1(r11);\
+	mtsdr1	r4;\
+	lwz	r4,SL_SPRG0(r11);\
+	mtsprg	0,r4;\
+	lwz	r4,SL_SPRG0+4(r11);\
+	mtsprg	1,r4;\
+	lwz	r4,SL_SPRG0+8(r11);\
+	mtsprg	2,r4;\
+	lwz	r4,SL_SPRG0+12(r11);\
+	mtsprg	3,r4;\
+;\
+/*	lwz	r4,SL_DBAT0(r11);\
+	mtdbatu	0,r4;\
+	lwz	r4,SL_DBAT0+4(r11);\
+	mtdbatl	0,r4;\
+	lwz	r4,SL_DBAT1(r11);\
+	mtdbatu	1,r4;\
+	lwz	r4,SL_DBAT1+4(r11);\
+	mtdbatl	1,r4;\
+	lwz	r4,SL_DBAT2(r11);\
+	mtdbatu	2,r4;\
+	lwz	r4,SL_DBAT2+4(r11);\
+	mtdbatl	2,r4;\
+	lwz	r4,SL_DBAT3(r11);\
+	mtdbatu	3,r4;\
+	lwz	r4,SL_DBAT3+4(r11);\
+	mtdbatl	3,r4;\
+	lwz	r4,SL_IBAT0(r11);\
+	mtibatu	0,r4;\
+	lwz	r4,SL_IBAT0+4(r11);\
+	mtibatl	0,r4;\
+	lwz	r4,SL_IBAT1(r11);\
+	mtibatu	1,r4;\
+	lwz	r4,SL_IBAT1+4(r11);\
+	mtibatl	1,r4;\
+	lwz	r4,SL_IBAT2(r11);\
+	mtibatu	2,r4;\
+	lwz	r4,SL_IBAT2+4(r11);\
+	mtibatl	2,r4;\
+	lwz	r4,SL_IBAT3(r11);\
+	mtibatu	3,r4;\
+	lwz	r4,SL_IBAT3+4(r11);\
+	mtibatl	3,r4;\
+; */ \
+BEGIN_FTR_SECTION;\
+	li	r4,0;\
+	mtspr	SPRN_DBAT4U,r4;\
+	mtspr	SPRN_DBAT4L,r4;\
+	mtspr	SPRN_DBAT5U,r4;\
+	mtspr	SPRN_DBAT5L,r4;\
+	mtspr	SPRN_DBAT6U,r4;\
+	mtspr	SPRN_DBAT6L,r4;\
+	mtspr	SPRN_DBAT7U,r4;\
+	mtspr	SPRN_DBAT7L,r4;\
+	mtspr	SPRN_IBAT4U,r4;\
+	mtspr	SPRN_IBAT4L,r4;\
+	mtspr	SPRN_IBAT5U,r4;\
+	mtspr	SPRN_IBAT5L,r4;\
+	mtspr	SPRN_IBAT6U,r4;\
+	mtspr	SPRN_IBAT6L,r4;\
+	mtspr	SPRN_IBAT7U,r4;\
+	mtspr	SPRN_IBAT7L,r4;\
+END_FTR_SECTION_IFSET(CPU_FTR_HAS_HIGH_BATS);\
+;\
+	/* Flush all TLBs */;\
+	lis	r4,0x1000;\
+1:	addic.	r4,r4,-0x1000;\
+	tlbie	r4;\
+	blt	1b;\
+	sync;\
+;\
+	/* restore the MSR and turn on the MMU */;\
+	lwz	r3,SL_MSR(r11);\
+	bl	turn_on_mmu;\
+	tovirt(r11,r11);\
+;\
+	/* Restore TB */;\
+	li	r3,0;\
+	mttbl	r3;\
+	lwz	r3,SL_TB(r11);\
+	lwz	r4,SL_TB+4(r11);\
+	mttbu	r3;\
+	mttbl	r4;\
+; \
+	lwz	r0,SL_CR(r11);\
+	mtcr	r0;\
+	lwz	r2,SL_R2(r11);\
+	lmw	r12,SL_R12(r11);\
+	lwz	r1,SL_SP(r11);\
+	lwz	r4,SL_LR(r11)
+
+#define CPU_REG_MEM_RESTORE_END \
+	/* Restore LR from the save area */		  ; \
+	lis	r11,cpu_reg_save_area@h			  ; \
+	ori	r11,r11,cpu_reg_save_area@l		  ; \
+	lwz	r0,SL_CR(r11)				  ; \
+	mtcr r0					  ; \
+	lwz	r2,SL_R2(r11)				  ; \
+	lmw	r12,SL_R12(r11)				  ; \
+	lwz	r1,SL_SP(r11)
+
+#define CPU_REG_TURN_ON_MMU \
+/* FIXME:This construct is actually not useful since we don't shut ; \
+ * down the instruction MMU, we could just flip back MSR-DR on.	; \
+ */							  ; \
+turn_on_mmu:						  ; \
+	mflr	r4					  ; \
+	mtsrr0	r4					  ; \
+	mtsrr1	r3					  ; \
+	sync						  ; \
+	isync						  ; \
+	rfi
+
+#define CPU_REG_STACK_SAVE \
+	mflr	r0					  ; \
+	stw	r0,4(r1)				  ; \
+	stwu	r1,-SL_SIZE(r1)				  ; \
+	mfcr	r0					  ; \
+	stw	r0,SL_CR(r1)				  ; \
+	stw	r2,SL_R2(r1)				  ; \
+	stmw	r12,SL_R12(r1)				  ; \
+	/* Save SPRGs */				  ; \
+	mfsprg	r4,0					  ; \
+	stw	r4,SL_SPRG0(r1)				  ; \
+	mfsprg	r4,1					  ; \
+	stw	r4,SL_SPRG0+4(r1)			  ; \
+	mfsprg	r4,2					  ; \
+	stw	r4,SL_SPRG0+8(r1)			  ; \
+	mfsprg	r4,3					  ; \
+	stw	r4,SL_SPRG0+12(r1)	
+
+#define CPU_REG_STACK_RESTORE \
+	lwz	r4,SL_SPRG0(r1)				  ; \
+	mtsprg	0,r4					  ; \
+	lwz	r4,SL_SPRG0+4(r1)			  ; \
+	mtsprg	1,r4					  ; \
+	lwz	r4,SL_SPRG0+8(r1)			  ; \
+	mtsprg	2,r4					  ; \
+	lwz	r4,SL_SPRG0+12(r1)			  ; \
+	mtsprg	3,r4					  ; \
+	lwz	r0,SL_CR(r1)				  ; \
+	mtcr	r0					  ; \
+	lwz	r2,SL_R2(r1)				  ; \
+	lmw	r12,SL_R12(r1)				  ; \
+	addi	r1,r1,SL_SIZE				  ; \
+	lwz	r0,4(r1)				  ; \
+	mtlr	r0					  ; \
+	blr
diff -ruN linux-2.6.7/arch/ppc/power/Makefile software-suspend-linux-2.6.7-rev10/arch/ppc/power/Makefile
--- linux-2.6.7/arch/ppc/power/Makefile	1970-01-01 10:00:00.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/ppc/power/Makefile	2004-07-08 14:37:07.000000000 +1000
@@ -0,0 +1,2 @@
+obj-$(CONFIG_PM) += cpu.o
+obj-$(CONFIG_SOFTWARE_SUSPEND2) += swsusp2-asm.o
diff -ruN linux-2.6.7/arch/ppc/power/swsusp2-asm.S software-suspend-linux-2.6.7-rev10/arch/ppc/power/swsusp2-asm.S
--- linux-2.6.7/arch/ppc/power/swsusp2-asm.S	1970-01-01 10:00:00.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/ppc/power/swsusp2-asm.S	2004-07-08 14:37:07.000000000 +1000
@@ -0,0 +1,53 @@
+/*
+ * This code base on pmdisk.S by Benjamin Herrenschmidt <benh@kernel.crashing.org>
+ *
+ * changed for swsusp2 by Hu Gang <hugang@soulinfo.com>
+ */
+#include <linux/config.h>
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/ppc_asm.h>
+#include <asm/cputable.h>
+#include <asm/cache.h>
+#include <asm/thread_info.h>
+#include <asm/offsets.h>
+#include "cpu_reg.S"
+
+	CPU_REG_MEM_DEFINE
+
+	.section .text
+	.align 5
+_GLOBAL(do_suspend2_lowlevel)
+	CPU_REG_STACK_SAVE
+	cmpwi	0,r3,0
+	bne	do_resume
+	bl	save_processor_state
+	bl	do_suspend2_suspend_1
+	CPU_REG_MEM_SAVE
+	bl	do_suspend2_suspend_2
+	CPU_REG_MEM_RESTORE_END 
+	CPU_REG_STACK_RESTORE
+	
+do_resume:
+	bl save_processor_state
+	bl do_suspend2_resume_1
+
+	/* Stop pending alitvec streams and memory accesses */
+BEGIN_FTR_SECTION
+	DSSALL
+END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
+ 	sync
+
+	CPU_REG_MEM_DISABLE_MMU 
+#include "swsusp2-copyback.S"
+	CPU_REG_MEM_FLUSH_CACHE
+	
+	CPU_REG_MEM_RESTORE
+	bl	do_suspend2_resume_2
+	bl	restore_processor_state
+	CPU_REG_MEM_RESTORE_END
+	CPU_REG_STACK_RESTORE
+
+	CPU_REG_TURN_ON_MMU
+
+	.section .text
diff -ruN linux-2.6.7/arch/ppc/power/swsusp2.c software-suspend-linux-2.6.7-rev10/arch/ppc/power/swsusp2.c
--- linux-2.6.7/arch/ppc/power/swsusp2.c	1970-01-01 10:00:00.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/ppc/power/swsusp2.c	2004-07-08 14:37:07.000000000 +1000
@@ -0,0 +1,170 @@
+ /*
+  * Copyright 2003 Nigel Cunningham.
+  *
+  * This is the code that the code in swsusp2-asm.S for
+  * copying back the original kernel is based upon. It
+  * was based upon code that is...
+  * Copyright 2001-2002 Pavel Machek <pavel@suse.cz>
+  * Based on code
+  * Copyright 2001 Patrick Mochel <mochel@osdl.org>
+  * Copyright 2004 Hu Gang <hugang@soulinfo.com
+  *  port to PowerPC
+  */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/sysrq.h>
+#include <linux/proc_fs.h>
+#include <linux/irq.h>
+#include <linux/pm.h>
+#include <linux/device.h>
+#include <linux/suspend.h>
+#include <linux/suspend-debug.h>
+#include <linux/suspend-common.h>
+#include <asm/uaccess.h>
+#if 0
+/* Local variables for do_swsusp2_suspend */
+volatile static int state1 __nosavedata = 0;
+volatile static int state2 __nosavedata = 0;
+volatile static int state3 __nosavedata = 0;
+volatile static int loop __nosavedata = 0;
+volatile static struct range *origrange __nosavedata;
+volatile static struct range *copyrange __nosavedata;
+volatile static int origoffset __nosavedata;
+volatile static int copyoffset __nosavedata;
+volatile static unsigned long * origpage __nosavedata;
+volatile static unsigned long * copypage __nosavedata;
+#endif
+
+//volatile static int orig_min_free __nosavedata;
+#ifndef CONFIG_SMP
+//static unsigned long c_loops_per_jiffy_ref __nosavedata = 0;
+//static unsigned long cpu_khz_ref __nosavedata = 0;
+#endif
+
+extern void do_swsusp2_suspend_1(void);
+extern void do_swsusp2_suspend_2(void);
+extern void do_swsusp2_resume_1(void);
+extern void do_swsusp2_resume_2(void);
+extern struct pagedir __nosavedata pagedir_resume;
+
+/*
+ * FIXME: This function should really be written in assembly. Actually
+ * requirement is that it does not touch stack, because %esp will be
+ * wrong during resume before restore_processor_context(). Check
+ * assembly if you modify this.
+ */
+#if 0
+static inline void pre_copyback(void)
+{
+#ifdef CONFIG_PREEMPT
+	/*
+	 * Preempt disabled in kernel we're about to restore.
+	 * Make sure we match state now.
+	 */
+	preempt_disable();
+	PRINTPREEMPTCOUNT("Prior to copying old kernel back.");
+#endif
+
+	state1 = swsusp_action;
+	state2 = swsusp_debug_state;
+	state3 = console_loglevel;
+
+#ifndef CONFIG_SMP
+	//c_loops_per_jiffy_ref = cpu_data->loops_per_jiffy;
+	//cpu_khz_ref = cpu_khz;
+#endif
+}
+static inline void post_copyback(void)
+{
+#ifndef CONFIG_SMP
+	//cpu_data->loops_per_jiffy = c_loops_per_jiffy_ref;
+	//loops_per_jiffy = c_loops_per_jiffy_ref;
+	//cpu_khz = cpu_khz_ref;
+#endif
+	swsusp_action = state1;
+	swsusp_debug_state = state2;
+	console_loglevel = state3;
+	//swsusp_min_free = orig_min_free;
+
+}
+#endif
+static inline void do_swsusp2_copyback(void)
+{
+	/* PowerPC has a lots register, use local register is possible */
+	register int origoffset, copyoffset;
+	register unsigned long * origpage, * copypage;
+	register struct range *origrange, *copyrange;
+//	register int pagesize;
+
+//	pre_copyback();
+
+	origrange = pagedir_resume.origranges.first;
+//	pagesize = pagedir_resume.pageset_size;
+//	printk("%d\n", pagesize);
+	origoffset = origrange->minimum;
+	origpage = (unsigned long *) (page_address(mem_map + origoffset));
+	
+	copyrange = pagedir_resume.destranges.first;
+	copyoffset = copyrange->minimum;
+	copypage = (unsigned long *) (page_address(mem_map + copyoffset));
+	//orig_min_free = swsusp_min_free;
+
+	while (origrange) {
+		register int loop;
+		for (loop = 0; loop < (PAGE_SIZE / sizeof(unsigned long)); loop++)
+			*(origpage + loop) = *(copypage + loop);
+		
+		if (origoffset < origrange->maximum) {
+			origoffset++;
+			origpage += (PAGE_SIZE / sizeof(unsigned long));
+		} else {
+			origrange = origrange->next;
+			if (origrange) {
+				origoffset = origrange->minimum;
+				origpage = (unsigned long *) (page_address(mem_map + origoffset));
+			}
+		}
+
+		if (copyoffset < copyrange->maximum) {
+			copyoffset++;
+			copypage += (PAGE_SIZE / sizeof(unsigned long));
+		} else {
+			copyrange = copyrange->next;
+			if (copyrange) {
+				copyoffset = copyrange->minimum;
+				copypage = (unsigned long *) (page_address(mem_map + copyoffset));
+			}
+		}
+	}
+	
+/* Ahah, we now run with our old stack, and with registers copied from
+   suspend time */
+
+//	post_copyback();
+}
+
+void do_swsusp_lowlevel(int resume)
+{
+	if (!resume) {
+		do_swsusp2_suspend_1();
+		save_processor_state();
+		/* saving stack */
+		
+		do_swsusp2_suspend_2();
+		return;
+	}
+
+	/* setup swapper_pg_dir in x86 */
+
+	do_swsusp2_resume_1();
+	do_swsusp2_copyback();
+	/* setup segment register */
+	restore_processor_state();
+	do_swsusp2_resume_2();
+}
diff -ruN linux-2.6.7/arch/ppc/power/swsusp2-copyback.S software-suspend-linux-2.6.7-rev10/arch/ppc/power/swsusp2-copyback.S
--- linux-2.6.7/arch/ppc/power/swsusp2-copyback.S	1970-01-01 10:00:00.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/arch/ppc/power/swsusp2-copyback.S	2004-07-08 14:37:07.000000000 +1000
@@ -0,0 +1,73 @@
+#define PAGE_TO_POINTER(in, out, p)	\
+	lwz out,0(in)					  ; \
+	slwi r9,out,2					  ; \
+	add r9,r9,out					  ; \
+	slwi r9,r9,3					  ; \
+	mullw r9,r9,r4					  ; \
+	slwi r9,r9,9					  ; \
+	addis p,r9,0xc000				  ; \
+	tophys(p,p)
+
+	.section ".text"
+swsusp2_copyback:
+	lis r20,pagedir_resume@ha	/* can't ture this is right FIXME */
+	addi r20,r20,pagedir_resume@l
+	tophys(r20,r20)
+#if 0
+	lwz	r4,4(r20)
+	twi	31,r0,0	/* triger trap */
+#endif	
+	lis r4,0xcccc /* FIXME */
+	ori r4,r4,52429
+
+	lwz r6,12(r20)		/* r6 is origranges.first */
+	cmpwi r6,0
+	beq- swsusp2_end_copyback
+		
+	tophys(r6,r6)
+	PAGE_TO_POINTER(r6,r8,r10)				  
+
+	lwz r5,56(r20)		/* r5 is copyranges.first */
+	tophys(r5,r5)
+	PAGE_TO_POINTER(r5,r7,r11) 
+	
+swsusp2_copy_one_page:
+	li r0,1024		/* r9 is loop */
+	mtctr r0		/* prepare for branch */
+	li r9,0
+swsusp2_copy_data:
+	lwzx r0,r9,r11
+	stwx r0,r9,r10
+	addi r9,r9,4
+
+	bdnz swsusp2_copy_data
+
+	lwz r0,4(r6)					  /* r0 is maximum */
+	cmplw r8,r0
+	bge- next_orig
+	addi r8,r8,1
+	addi r10,r10,4096
+	b end_orig
+next_orig:
+	lwz r6,8(r6)	/* r6 origrange */
+	cmpwi r6,0
+	beq- end_orig
+	tophys(r6,r6)
+	PAGE_TO_POINTER(r6,r8,r10)
+end_orig:
+	lwz r0,4(r5)					  /* r0 is maximum */
+	cmplw r7,r0
+	bge- next_copy
+	addi r7,r7,1
+	addi r11,r11,4096
+	b end_copy
+next_copy:
+	lwz r5,8(r5)	/* r5 is copypage */
+	cmpwi r5,0
+	beq- end_copy
+	tophys(r5,r5)
+	PAGE_TO_POINTER(r5,r7,r11)
+end_copy:
+	cmpwi 0,r6,0
+	bc r4,r2,swsusp2_copy_one_page
+swsusp2_end_copyback:
diff -ruN linux-2.6.7/Documentation/kernel-parameters.txt software-suspend-linux-2.6.7-rev10/Documentation/kernel-parameters.txt
--- linux-2.6.7/Documentation/kernel-parameters.txt	2004-06-18 12:43:52.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/Documentation/kernel-parameters.txt	2004-07-08 14:37:07.000000000 +1000
@@ -741,6 +741,8 @@
 
 	noresume	[SWSUSP] Disables resume and restore original swap space.
  
+	noresume2	[SWSUSP2] Disables resuming and restores original swap signature.
+ 
 	no-scroll	[VGA] Disables scrollback.
 			This is required for the Braillex ib80-piezo Braille
 			reader made by F.H. Papenmeier (Germany).
@@ -938,7 +940,12 @@
 
 	reserve=	[KNL,BUGS] Force the kernel to ignore some iomem area
 
-	resume=		[SWSUSP] Specify the partition device for software suspension
+	resume=		[SWSUSP] Specify the partition device for software suspension.
+
+	resume2=	[SWSUSP2] Specify the storage device for software suspend.
+			Format: <writer>:<writer-parameters>.
+			See Documentation/power/swsusp2.txt for details of the formats
+			for available image writers.
 
 	rhash_entries=	[KNL,NET]
 			Set number of hash buckets for route cache
diff -ruN linux-2.6.7/Documentation/power/swsusp2.txt software-suspend-linux-2.6.7-rev10/Documentation/power/swsusp2.txt
--- linux-2.6.7/Documentation/power/swsusp2.txt	1970-01-01 10:00:00.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/Documentation/power/swsusp2.txt	2004-07-08 14:37:07.000000000 +1000
@@ -0,0 +1,495 @@
+   --- Software Suspend ('swsusp') for Linux, version 2.0 ---
+
+1.  What is it?
+2.  Why would you want it?
+3.  What do you need to use it?
+4.  How do you use it?
+5.  What do all those entries in /proc/swsusp do?
+6.  How do you get support?
+7.  I think I've found a bug. What should I do?
+8.  When will XXX be supported?
+9.  How does it work?
+10. Who wrote Software Suspend?
+
+1. What is it?
+
+   Imagine you're sitting at your computer, working away. For some reason, you
+   need to turn off your computer for a while - perhaps it's time to go home
+   for the day. When you come back to your computer next, you're going to want
+   to carry on where you left off. Now imagine that you could push a button and
+   have your computer store the contents of its memory to disk and power down.
+   Then, when you next start up your computer, it loads that image back into
+   memory and you can carry on from where you were, just as if you'd never
+   turned the computer off. Far less time to start up, no reopening
+   applications and finding what directory you put that file in yesterday.
+   That's what Software Suspend does.
+
+2. Why would you want it?
+
+   Why wouldn't you want it?
+   
+   Being able to save the state of your system and quickly restore it improves
+   your productivity - you get a useful system in far less time than through
+   the normal boot process.
+   
+3. What do you need to use it?
+
+   a. Kernel Support.
+   
+   Software Suspend is part of the Linux Kernel. This version is not part of Linus's
+   2.6 tree at the moment, so you will need to download the kernel source and
+   apply the latest patch. Having done that, enable the appropriate options in
+   make [menu|x]config (under General Setup), compile and install your kernel.
+   Software Suspend is incompatible with SMP, and non x86 hardware but
+   works with preempt support and HighMem. It requires your swap 
+   partitions/files to be on IDE devices.
+
+   Software Suspend patches are available from http://swsusp.sf.net.
+
+   You may also want to apply the optional patches. At the time of writing,
+   option patches are available to support Bootsplash (www.bootsplash.org, for
+   an even nicer display during suspend), Laptop mode and Win4Lin. The laptop
+   mode patch is a variation on Jens Axboe's patch, which disables laptop mode
+   when suspending. The Win4Lin option patch provides support for Win4Lin.
+   
+   Option patches should be applied after the main patch and after Win4Lin
+   or Bootsplash.
+   
+   b. Swapspace.
+
+   Software Suspend can store the suspend image in your swap partition,
+   a swap file or a combination thereof. Whichever combination you choose, you
+   will probably want to create enough swap space to store the largest image
+   you could have, plus the space you'd normally use for swap. A good rule of
+   thumb would be to calculate the amount of swap you'd want without using
+   Software Suspend, and then add the amount of memory you have. This swap
+   space can be arranged in any way you'd like. It can be in one partition or
+   file, or spread over a number. The only requirement is that they be active
+   when you start a suspend cycle.
+   
+   There is one exception to this requirement. Software Suspend has
+   the ability to turn on one swap file or partition at the start of
+   suspending and turn it back off at the end. If you want to ensure you have
+   enough memory to store a image when your memory is fully used, you might 
+   want to make one swap partition/file for 'normal' use, and another for
+   Software Suspend to activate & deactivate automatically. (Further details
+   below).
+
+   c. Bootloader configuration.
+   
+   Using Software Suspend also requires that you add an extra parameter to 
+   your lilo.conf or equivalent. Here's an example for a swap partition:
+
+   append="resume=/dev/hda1"
+
+   This would tell Software Suspend that /dev/hda1 is a swap partition you 
+   have. Software Suspend will use the swap signature of this partition as a
+   pointer to your data when you suspend. This means that (in this example)
+   /dev/hda1 doesn't need to be _the_ swap partition where all of your data
+   is actually stored. It just needs to be a swap partition that will be
+   turned on at suspend time.
+
+   You don't need to have a swap partition for this purpose. Software Suspend
+   can also use a swap file, but usage is a little more complex. Having made
+   your swap file, turn it on and do "cat /proc/swsusp/header_locations"
+   (this assumes you've already compiled your kernel with Software Suspend
+   support and booted it). The results of the cat command will tell you
+   what you need to put in lilo.conf:
+
+   For swap partitions like /dev/hda1, simply use resume=/dev/hda1.
+   For swapfile `swapfile`, use resume=/dev/hda2 resume_block=0x242d.
+
+   If the swapfile changes for any reason (it is moved to a different
+   location, it is deleted and recreated, or the filesystem is
+   defragmented) then you will have to check
+   /proc/swsusp/header_locations for a new resume_block value.
+
+   Once you've compiled and installed the kernel, adjusted your lilo.conf
+   and rerun lilo, you should only need to reboot for the most basic part
+   of Software Suspend to be ready.
+
+   d. A suspend script.
+
+   Since the driver model in 2.6 kernels is still being developed, you may need
+   to do more, however. Users of Software Suspend usually start the process 
+   via a script which prepares for the suspend, tells the kernel to do its
+   stuff and then restore things afterwards. This script might involve:
+
+   - Switching to a text console and back if X doesn't like the video card
+     status on resume.
+   - Running /sbin/hwclock [--directisa] to update the clock on resume
+   - Un/reloading PCMCIA support since it doesn't play well with swsusp.
+  
+   Note that you might not be able to unload some drivers if there are 
+   processes using them. You might have to kill off processes that hold
+   devices open. Hint: if your X server accesses an USB mouse, doing a
+   'chvt' to a text console releases the device and you can unload the
+   module.
+
+   Check out the latest script (available on Sourceforge).
+   
+4. How do you use it?
+
+   Once your script is properly set up, you should just be able to start it
+   and everything should go like clockwork. Of course things aren't always
+   that easy out of the box.
+
+   Check out (in the kernel source tree) include/linux/suspend-debug for
+   settings you can use to get detailed information about what swsusp is doing.
+   /proc/sys/kernel/swsusp and the kernel parameters swsusp_act, swsusp_dbg
+   and swsusp_lvl allow you to set the action and debugging parameters prior
+   to starting a suspend and/or at the lilo prompt before resuming. There is
+   also a nice little program that should be available from Sourceforge which
+   makes it easier to turn these debugging settings on and off. Note that to
+   get any debugging output, you need to enable it when compiling the kernel.
+   If cat /proc/sys/kernel/swsusp only shows 4 numbers, you didn't do that.
+
+   A neat feature of Software Suspend is that you can press Escape at any time
+   during suspending, and the process will be aborted.
+   
+   Due to the way swsusp works, this means you'll have your system back and
+   perfectly usable almost instantly. The only exception is when it's at
+   the very end of writing the image. Then it will need to reload a small
+   (usually 4-50MBs) portion first.
+
+   If you run into problems with resuming, adding the "noresume" option to
+   the kernel command line will let you skip the resume step and
+   (hopefully) recover your system.
+
+5. What do all those entries in /proc/swsusp do?
+
+   /proc/swsusp is the directory which contains files you can use to tune
+   and configure Software Suspend to your liking. The exact contents of
+   the directory will depend upon the version of Software Suspend you're
+   running, and the options you selected at compile time. In the following
+   descriptions, names in brackets refer to compile time options that
+   control whether the file exists. (Note that they're all dependant upon
+   you having selected CONFIG_SOFTWARE_SUSPEND2 in the first place!)
+
+   Since the values of these settings can open potential security risks, they
+   are usually accessible only to the root user. You can, however, enable a
+   compile time option which makes all of these files world-accessible. This
+   should only be done if you trust everyone with shell access to this
+   computer!
+  
+   - activate:
+
+   When anything is written to this file swsusp will be activated and suspend
+   the system. The value is completely ignored. It is just the fact that you
+   write to the file that initiates the suspend.
+
+   - async_io_limit:
+
+   This value is the limit on the number of pages Software Suspend will submit
+   for reading or writing at once. The ideal value depends upon the speed of
+   your hard disks, but the default of 32 should be fine.
+
+   - beeping:
+
+   Set this value to 1 to hear beeps at the different stages of suspending and
+   resuming.
+
+   - debug_info:
+  
+   This file returns information about your configuration that may be helpful
+   in diagnosing problems with suspending.
+
+   - debug_sections (CONFIG_SOFTWARE_SUSPEND_DEBUG):
+
+   This value, together with the console log level, controls what debugging
+   information is displayed. The console log level determines the level of
+   detail, and this value determines what detail is displayed. This value is
+   a bit vector, and the meaning of the bits can be found in the kernel tree
+   in include/linux/suspend-debug.h. It can be over-ridden using the kernel's
+   command line option swsusp_dbg.
+
+   - default_console_level (CONFIG_SOFTWARE_SUSPEND_DEBUG):
+
+   This determines the value of the console log level at the start of a
+   suspend cycle. If debugging is compiled in, the console log level can be
+   changed during a cycle by pressing the digit keys. Meanings are:
+
+   0: Nice display.
+   1: Nice display plus numerical progress.
+   2: Errors only.
+   3: Low level debugging info.
+   4: Medium level debugging info.
+   5: High level debugging info.
+   6: Verbose debugging info.
+
+   This value can be over-ridden using the kernel command line option 
+   swsusp_lvl.
+
+   - disable_gzip_compression (CONFIG_SOFTWARE_SUSPEND_GZIP_COMPRESSION):
+
+   If gzip compression support is compiled in, this option can be used to 
+   disable this plugin.
+
+   - disable_lzf_compression (CONFIG_SOFTWARE_SUSPEND_LZF_COMPRESSION):
+
+   If lzf compression support is compiled in, this option can be used to 
+   disable this plugin.
+
+   - enable_escape:
+
+   Setting this to "1" will enable you abort a suspend by
+   pressing escape, "0" (default) disables this feature. Note that enabling
+   this option means that you cannot initiate a suspend and then walk away
+   from your computer, expecting it to be secure. With feature disabled,
+   you can validly have this expectation once Suspend begins to write the
+   image to disk. (Prior to this point, it is possible that Suspend might
+   about because of failure to freeze all processes or because constraints
+   on its ability to save the image are not met).
+
+   - expected_gzip_compression (CONFIG_SOFTWARE_SUSPEND_GZIP_COMPRESSION):
+   - expected_lzf_compression (CONFIG_SOFTWARE_SUSPEND_LZF_COMPRESSION):
+
+   These values allow you to set an expected compression ratio, which Software
+   Suspend will use in calculating whether it meets constraints on the image
+   size. If this expected compression ratio is not attained, the suspend will
+   abort, so it is wise to allow some spare. You can see what compression
+   ratio is achieved in the logs after suspending.
+
+   Note that the values are cumulative. If you compile in both gzip and lzf
+   compression, have both enabled, and set both expected compression ratios
+   to 20, Suspend will expect that the storage required  will be at most 
+   .8 * .8 = 64% of the number of pages to be written.
+
+   - header_locations:
+
+   This option tells you the resume= options to use for swap devices you
+   currently have activated. It is particularly useful when you only want to
+   use a swap file to store your image. See above for further details.
+
+   - image_size_limit:
+
+   The maximum size of suspend image written to disk, measured in megabytes
+   (1024*1024).
+
+   - interface_version:
+
+   The value returned by this file can be used by scripts and configuration
+   tools to determine what entries should be looked for. The value is
+   incremented whenever an entry in /proc/swsusp is obsoleted or added.
+
+   - last_result:
+
+   The result of the last suspend, as defined in
+   include/linux/suspend-debug.h with the values SUSPEND_ABORTED to
+   SUSPEND_KEPT_IMAGE. This is a bitmask.
+
+   - log_everything (CONFIG_SOFTWARE_SUSPEND_DEBUG):
+
+   Setting this option results in all messages printed being logged. Normally,
+   only a subset are logged, so as to not slow the process and not clutter the
+   logs. Useful for debugging. It can be toggled during a cycle by pressing
+   'L'.
+
+   - no_output:
+
+   Setting this to "1" disables all output from suspend. It may be useful if a
+   distribution wants to implement a static display while suspending.
+
+   - pause_between_steps (CONFIG_SOFTWARE_SUSPEND_DEBUG):
+
+   This option is used during debugging, to make Software Suspend pause between
+   each step of the process. It is ignored when the nice display is on.
+
+   - progressbar_granularity_limit (CONFIG_FBCON_SPLASHSCREEN):
+
+   This option can be used to limit the granularity of the progress bar
+   displayed with a bootsplash screen. The value is the maximum number of
+   steps. That is, 10 will make the progress bar jump in 10% increments.
+
+   - reboot (CONFIG_SOFTWARE_SUSPEND_DEBUG):
+
+   This option causes Software Suspend to reboot rather than powering down
+   at the end of saving an image. It can be toggled during a cycle by pressing
+   'R'.
+
+   - slow:
+
+   This option inserts a couple of one+ second delays in the code. It should
+   not be needed, and may disappear in a future version.
+
+   - swapfile:
+
+   This entry is used to specify the swapfile or partition that
+   Software Suspend will attempt to swapon/swapoff automatically. Thus, if
+   I normally use /dev/hda1 for swap, and want to use /dev/hda2 for specifically
+   for my suspend image, I would
+  
+   echo /dev/hda2 > /proc/swsusp/swapfile
+
+   /dev/hda2 would then be automatically swapon'd and swapoff'd. Note that the
+   swapon and swapoff occur while other processes are frozen (including kswapd)
+   so this swap file will not be used up when attempting to free memory. The
+   parition/file is also given the highest priority, so other swapfiles/partitions
+   will only be used to save the image when this one is filled.
+
+   The value of this file is used by header_locations along with any currently
+   activated swapfiles/partitions.
+
+   - version:
+  
+   The version of swsusp you have compiled into the currently running kernel.
+
+6. How do you get support?
+
+   Glad you asked. Software Suspend is being actively maintained and supported,
+   both by Nigel (the guy doing most of the coding at the moment) and its
+   users. You can find the mailing list via the Sourceforge project page.
+
+7. I think I've found a bug. What should I do?
+
+   If you're seeing Software Suspend hang at some point, and especially if
+   lights are flashing on your keyboard, you should compile in debugging 
+   support and try...
+   
+   echo 1 > /proc/swsusp/debug_sections
+   echo 3 > /proc/swsusp/default_console_level
+   echo > /proc/swsusp/activate
+
+   You should then see low level debugging information and eventually an
+   oops.
+
+   Good information on how to provide us with useful information from an
+   oops is found in the file REPORTING-BUGS, in the top level directory
+   of the kernel tree. If you get an oops, please especially note the
+   information about running what is printed on the screen through ksymoops.
+   The raw information is useless.
+
+   You might also read the FAQ and HOWTO on the web site for known issues,
+   and subscribe to the mailing list.
+
+   Beginning with 1.1rc10, you should include the contents of 
+   /proc/swsusp/debug_info in your report. Prior to this version, similar
+   information is written to /var/log/messages at the end of a successful
+   resume and should be sent. It is also a good idea to check /var/log/messages
+   for relevant information as well. Information from the unloading and 
+   reloading of drivers and modules  prior to and after suspending is sometimes
+   helpful.
+
+8. When will XXX be supported?
+
+   Software Suspend currently lacks support for SMP, non x86 and SCSI.
+
+   Patches for the other items (and anything that's been missed) are welcome. 
+   Please send to the list.
+
+   Because Nigel's main task is definitely not Software Suspend and he doesn't
+   have the hardware, he will be unlikely to develop support for any of these
+   in the near future. His development work to date has been driven by the
+   desire to be a user of a more feature complete Software Suspend.
+
+9. How does it work?
+
+   Software Suspend does its work in a number of steps.
+
+   a. Freezing system activity.
+
+   The first main stage in suspending is to stop all other activity. This is
+   achieved in stages. First, we stop tasks from submitting new I/O using hooks
+   in the system calls for reading, writing and at a number of other places as
+   well as at the kernel threads that start I/O. If any tasks are syncing,
+   we wait for them to complete. We then do our own sync, just in case no
+   syncs were running. Next, we stop all the others tasks. Some are signalled
+   and put in a 'refrigerator'. Others are simply not scheduled again until we
+   decide to wake them up.
+
+   b. Eating memory.
+
+   For a successful suspend, you need to have enough disk space to store the
+   image and enough memory for the various limitations of Software Suspend's
+   algorithm. You can also specify a maximum image size. In order to attain
+   to those constraints, Software Suspend may 'eat' memory. If, after freezing
+   processes, the constraints aren't met, Software Suspend will thaw all the
+   other processes and begin to eat memory until its calculations indicate
+   the constraints are met. It will then freeze processes again and recheck
+   its calculations.
+
+   c. Suspending drivers and storing processor context.
+
+   Software Suspend then calls the power management functions to notify
+   drivers of the suspend, and saves the processor state.
+
+   d. Storage of meta data and image.
+
+   Next, Software Suspend allocates the swap pages that will be used to save
+   the image and stores their locations, along with the locations of the pages
+   to be saved in what we call pagesets or pagedirs. Software Suspend stores
+   data in two pagesets. Pageset 2 contains pages on the active and inactive
+   lists; essentially the page cache. Pageset 1 contains all other pages,
+   including the kernel. We use two pagesets for one important reason: We
+   need to make an atomic copy of the kernel to ensure consistency of the
+   image. Without a second pagedir, that would limit us to an image that was
+   at most half the amount of memory available. Using two pagesets allows us
+   to store a full image. Since pageset 2 pages won't be needed in saving
+   pageset 1, we first save pageset 2 pages. We can then make our atomic copy
+   of the remaining pages using both pageset 2 pages and any other pages that
+   are free. While saving both pagesets, we are careful not to corrupt the
+   image. We immediately shoot down pages that are added to the page cache,
+   and we allocate a special memory pool of extra pages that can be used by
+   during suspending. All of the pages in this pool are saved along with the
+   rest of the pageset 1 pages, even if they're not used. This saves us having
+   to worry about the image becoming inconsistent while we're saving it.
+
+   e. Save a second copy of the pagedirs.
+
+   To reload pagedir 1 at resume time, we need to know where the data is
+   stored. This requires the saving of a second copy of the pagedirs.
+
+   f. Save the suspend header.
+
+   Nearly there! We save our settings and other parameters needed for
+   reloading pagedir 1 in a 'suspend header' this is a single swap page.
+
+   g. Set the swap header.
+
+   Finally, we edit the swap header for our resume= swap file/partition. The
+   swap signature is changed to record what kind of header it originally was
+   (swapspace 1 or 2) and the bdev and first block and block size details of
+   the suspend header.
+
+   h. Power down.
+
+   Or reboot if we're debugging and the appropriate option is selected.
+
+   Whew!
+
+   Reloading the image.
+   --------------------
+
+   Reloading the image is essentially the reverse of all the above. We load
+   our copy of pagedir 1, being careful to choose locations that aren't going
+   to be overwritten as we copy it back (We start very early in the boot
+   process, so there are no other processes to quiesce here). We then copy
+   pagedir 1 back to its original location in memory and restore the process
+   context. We are now running with the original kernel. Next, we reload the
+   pageset 2 pages, free the memory and swap used by Software Suspend, restore
+   the pagedir header and restart processes. Sounds easy in comparison to
+   suspending, doesn't it!
+
+   There is of course more to Software Suspend than this, but this explanation
+   should be a good start. If there's interest, I'll write further
+   documentation on range pages and the low level I/O.
+
+10. Who wrote Software Suspend?
+
+   (Answer based on the writings of Florent Chabaud, credits in files and
+   Nigel's limited knowledge; apologies to anyone missed out!)
+
+   The main developers of Software Suspend have been...
+
+   Gabor Kuti
+   Pavel Machek
+   Florent Chabaud
+   Nigel Cunningham
+
+   They have been aided in their efforts by a host of hundreds, if not thousands
+   of testers and people who have submitted bug fixes & suggestions. Of special
+   note are the efforts of Michael Frank, who had his computers repetitively
+   suspend and resume for literally tens of thousands of cycles and developed
+   scripts to stress the system and test Software Suspend far beyond the point
+   most of us (Nigel included!) would consider testing. His efforts have
+   contributed as much to Software Suspend as any of the names above.
diff -ruN linux-2.6.7/drivers/acpi/osl.c software-suspend-linux-2.6.7-rev10/drivers/acpi/osl.c
--- linux-2.6.7/drivers/acpi/osl.c	2004-06-18 12:43:57.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/acpi/osl.c	2004-07-08 14:37:07.000000000 +1000
@@ -81,7 +81,7 @@
 		return AE_NULL_ENTRY;
 	}
 #endif
-	kacpid_wq = create_singlethread_workqueue("kacpid");
+	kacpid_wq = create_singlethread_workqueue("kacpid", 0);
 	BUG_ON(!kacpid_wq);
 
 	return AE_OK;
diff -ruN linux-2.6.7/drivers/acpi/sleep/proc.c software-suspend-linux-2.6.7-rev10/drivers/acpi/sleep/proc.c
--- linux-2.6.7/drivers/acpi/sleep/proc.c	2004-04-17 03:21:03.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/acpi/sleep/proc.c	2004-07-08 14:37:07.000000000 +1000
@@ -67,6 +67,17 @@
 		goto Done;
 	}
 	state = simple_strtoul(str, NULL, 0);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	/* 
+	 * I used to put this after the CONFIG_SOFTWARE_SUSPEND
+	 * test, but people who compile in suspend2 usually want
+	 * to use it instead of swsusp.   --NC
+	 */
+	if (state == 4) {
+		software_suspend_pending();
+		goto Done;
+	}
+#endif
 #ifdef CONFIG_SOFTWARE_SUSPEND
 	if (state == 4) {
 		software_suspend();
diff -ruN linux-2.6.7/drivers/base/power/main.c software-suspend-linux-2.6.7-rev10/drivers/base/power/main.c
--- linux-2.6.7/drivers/base/power/main.c	2004-07-08 11:41:35.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/base/power/main.c	2004-07-08 14:37:07.000000000 +1000
@@ -26,6 +26,7 @@
 LIST_HEAD(dpm_active);
 LIST_HEAD(dpm_off);
 LIST_HEAD(dpm_off_irq);
+LIST_HEAD(dpm_retain_state);
 
 DECLARE_MUTEX(dpm_sem);
 
diff -ruN linux-2.6.7/drivers/base/power/power.h software-suspend-linux-2.6.7-rev10/drivers/base/power/power.h
--- linux-2.6.7/drivers/base/power/power.h	2004-01-13 14:16:20.000000000 +1100
+++ software-suspend-linux-2.6.7-rev10/drivers/base/power/power.h	2004-07-08 14:37:07.000000000 +1000
@@ -33,6 +33,7 @@
 extern struct list_head dpm_active;
 extern struct list_head dpm_off;
 extern struct list_head dpm_off_irq;
+extern struct list_head dpm_retain_state;
 
 
 static inline struct dev_pm_info * to_pm_info(struct list_head * entry)
diff -ruN linux-2.6.7/drivers/base/power/resume.c software-suspend-linux-2.6.7-rev10/drivers/base/power/resume.c
--- linux-2.6.7/drivers/base/power/resume.c	2004-06-18 12:43:59.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/base/power/resume.c	2004-07-08 14:37:07.000000000 +1000
@@ -97,6 +97,59 @@
 	dpm_power_up();
 }
 
+
+#if 0
+
+/**
+ *
+ * 	pci_find_class_storage
+ *
+ *	Find a PCI storage device.
+ *	Based upon pci_find_class, but less strict.
+ */
+
+static struct pci_dev *
+pci_find_class_storage(unsigned int class, const struct pci_dev *from)
+{
+	struct list_head *n;
+	struct pci_dev *dev;
+
+	spin_lock(&pci_bus_lock);
+	n = from ? from->global_list.next : pci_devices.next;
+
+	while (n && (n != &pci_devices)) {
+		dev = pci_dev_g(n);
+		if (((dev->class & 0xff00) >> 16) == class)
+			goto exit;
+		n = n->next;
+	}
+	dev = NULL;
+exit:
+	spin_unlock(&pci_bus_lock);
+	return dev;
+}
+
+
+/**
+ *	device_resume_type - Resume some devices.
+ *
+ *	Resume devices of a specific type and their parents.
+ *	Interrupts must be disabled when calling this.
+ *
+ *	Note that we only handle pci devices at the moment.
+ *	We have no way that I can tell of getting the class
+ *	of devices not on the pci bus.
+ */
+void device_resume_type(type)
+{
+	struct device * dev_dev;
+	struct pci_dev * pci_dev = NULL;
+	
+	while ((dev = pci_find_class(PCI_BASE_CLASS_STORAGE, dev))) {
+	}
+}
+#endif
+
 EXPORT_SYMBOL(device_power_up);
 
 
diff -ruN linux-2.6.7/drivers/base/power/suspend.c software-suspend-linux-2.6.7-rev10/drivers/base/power/suspend.c
--- linux-2.6.7/drivers/base/power/suspend.c	2004-06-18 12:43:59.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/base/power/suspend.c	2004-07-08 14:37:07.000000000 +1000
@@ -134,3 +134,24 @@
 
 EXPORT_SYMBOL(device_power_down);
 
+void device_set_retain_state(struct device * dev)
+{
+	down(&dpm_sem);
+	while (dev) {
+		list_del(&dev->power.entry);
+		list_add(&dev->power.entry, &dpm_retain_state);
+		dev = dev->parent;
+	}
+	up(&dpm_sem);
+}
+
+void device_flush_retain_state(void)
+{
+	down(&dpm_sem);
+	while(!list_empty(&dpm_retain_state)) {
+		struct list_head * entry = dpm_retain_state.next;
+		list_del_init(entry);
+		list_add_tail(entry,&dpm_active);
+	}
+	up(&dpm_sem);
+}
diff -ruN linux-2.6.7/drivers/block/ll_rw_blk.c software-suspend-linux-2.6.7-rev10/drivers/block/ll_rw_blk.c
--- linux-2.6.7/drivers/block/ll_rw_blk.c	2004-06-18 12:43:59.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/block/ll_rw_blk.c	2004-07-08 14:37:07.000000000 +1000
@@ -2819,7 +2819,7 @@
 
 int __init blk_dev_init(void)
 {
-	kblockd_workqueue = create_workqueue("kblockd");
+	kblockd_workqueue = create_workqueue("kblockd", PF_NOFREEZE);
 	if (!kblockd_workqueue)
 		panic("Failed to create kblockd\n");
 
diff -ruN linux-2.6.7/drivers/block/loop.c software-suspend-linux-2.6.7-rev10/drivers/block/loop.c
--- linux-2.6.7/drivers/block/loop.c	2004-06-18 12:43:59.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/block/loop.c	2004-07-08 14:37:07.000000000 +1000
@@ -63,7 +63,6 @@
 #include <linux/swap.h>
 #include <linux/slab.h>
 #include <linux/loop.h>
-#include <linux/suspend.h>
 #include <linux/writeback.h>
 #include <linux/buffer_head.h>		/* for invalidate_bdev() */
 #include <linux/completion.h>
diff -ruN linux-2.6.7/drivers/char/hvc_console.c software-suspend-linux-2.6.7-rev10/drivers/char/hvc_console.c
--- linux-2.6.7/drivers/char/hvc_console.c	2004-04-17 03:21:04.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/char/hvc_console.c	2004-07-08 14:37:07.000000000 +1000
@@ -270,6 +270,7 @@
 	int i;
 
 	daemonize("khvcd");
+	current->flags |= PF_NOFREEZE;
 
 	for (;;) {
 		if (cpus_empty(cpus_in_xmon)) {
diff -ruN linux-2.6.7/drivers/char/keyboard.c software-suspend-linux-2.6.7-rev10/drivers/char/keyboard.c
--- linux-2.6.7/drivers/char/keyboard.c	2004-02-18 19:15:32.000000000 +1100
+++ software-suspend-linux-2.6.7-rev10/drivers/char/keyboard.c	2004-07-08 14:37:07.000000000 +1000
@@ -33,6 +33,7 @@
 #include <linux/string.h>
 #include <linux/random.h>
 #include <linux/init.h>
+#include <linux/completion.h>
 #include <linux/slab.h>
 
 #include <linux/kbd_kern.h>
@@ -41,9 +42,15 @@
 #include <linux/sysrq.h>
 #include <linux/input.h>
 
+#include <linux/suspend.h>
+
 static void kbd_disconnect(struct input_handle *handle);
 extern void ctrl_alt_del(void);
 
+#ifdef CONFIG_PM
+extern void wakeup_suspend(void);
+#endif
+
 /*
  * Exported functions/variables
  */
@@ -1069,6 +1076,159 @@
 		return;
 	}
 #endif
+#ifdef CONFIG_PM
+	if (down && (software_suspend_state & SOFTWARE_SUSPEND_RUNNING)) {
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		extern void prepare_status(int printalways, int clearbar, const char *fmt, ...);
+		extern unsigned long suspend_action;
+		extern void request_abort_suspend(void);
+		extern void machine_restart(char * __unused);
+		if (software_suspend_state & SOFTWARE_SUSPEND_SANITY_CHECK_PROMPT) {
+			if (keycode == 57)
+				wakeup_suspend();
+			else if (keycode == 46) {
+				software_suspend_state |= SOFTWARE_SUSPEND_CONTINUE_REQ;
+				wakeup_suspend();
+			}
+			return;
+		}
+		switch (keycode) {
+			case 1:
+				/* Abort suspend */
+				request_abort_suspend();
+				wakeup_suspend();
+				break;
+			case 2:
+				console_loglevel = 1;
+				wakeup_suspend();
+				break;
+			case 11:
+				console_loglevel = 0;
+				wakeup_suspend();
+				break;
+			case 19:
+				/* Otherwise, if R pressed, toggle rebooting */
+				suspend_action ^= (1 << SUSPEND_REBOOT);
+				schedule_suspend_message(2);
+				wakeup_suspend();
+				break;
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+			case 41:
+				/* `: Toggle slow */
+				suspend_action ^= (1 << SUSPEND_SLOW);
+				schedule_suspend_message(7);
+				wakeup_suspend();
+				break;
+			case 59:
+				/* F1: Toggle any section debugging. */
+				suspend_debug_state ^= (1 << SUSPEND_ANY_SECTION);
+				schedule_suspend_message(20);
+				wakeup_suspend();
+				break;
+			case 60:
+				/* F2: Freeze. */
+				suspend_debug_state ^= (1 << SUSPEND_FREEZER);
+				schedule_suspend_message(21);
+				wakeup_suspend();
+				break;
+			case 61:
+				/* F3: Eat Memory */
+				suspend_debug_state ^= (1 << SUSPEND_EAT_MEMORY);
+				schedule_suspend_message(22);
+				wakeup_suspend();
+				break;
+			case 62:
+				/* F4: Pagesets. */
+				suspend_debug_state ^= (1 << SUSPEND_PAGESETS);
+				schedule_suspend_message(23);
+				wakeup_suspend();
+				break;
+			case 63:
+				/* F5: IO. */
+				suspend_debug_state ^= (1 << SUSPEND_IO);
+				schedule_suspend_message(24);
+				wakeup_suspend();
+				break;
+			case 64:
+				/* F6: Bmapping of pages */
+				suspend_debug_state ^= (1 << SUSPEND_BMAP);
+				schedule_suspend_message(25);
+				wakeup_suspend();
+				break;
+			case 65:
+				/* F7: Swap */
+				suspend_debug_state ^= (1 << SUSPEND_SWAP);
+				schedule_suspend_message(26);
+				wakeup_suspend();
+				break;
+			case 66:
+				/* F8: Memory */
+				suspend_debug_state ^= (1 << SUSPEND_MEMORY);
+				schedule_suspend_message(27);
+				wakeup_suspend();
+				break;
+			case 67:
+				/* F9: Ranges */
+				suspend_debug_state ^= (1 << SUSPEND_RANGES);
+				schedule_suspend_message(28);
+				wakeup_suspend();
+				break;
+			case 68:
+				/* F10: Memory Pool */
+				suspend_debug_state ^= (1 << SUSPEND_MEM_POOL);
+				schedule_suspend_message(29);
+				wakeup_suspend();
+				break;
+			case 87:
+				/* F11: Nosave */
+				suspend_debug_state ^= (1 << SUSPEND_NOSAVE);
+				schedule_suspend_message(30);
+				wakeup_suspend();
+				break;
+			case 88:
+				/* F12: Integrity */
+				suspend_debug_state ^= (1 << SUSPEND_INTEGRITY);
+				schedule_suspend_message(31);
+				wakeup_suspend();
+				break;
+			case 25:
+				/* During suspend, toggle pausing with P */
+				suspend_action ^= (1 << SUSPEND_PAUSE);
+				schedule_suspend_message(1);
+				wakeup_suspend();
+				break;
+			case 31:
+				/* Otherwise, if S pressed, toggle single step */
+				suspend_action ^= (1 << SUSPEND_SINGLESTEP);
+				schedule_suspend_message(3);
+				wakeup_suspend();
+				break;
+			case 38:
+				/* Otherwise, if L pressed, toggle logging everything */
+				suspend_action ^= (1 << SUSPEND_LOGALL);
+				schedule_suspend_message(4);
+				wakeup_suspend();
+				break;
+			case 3:
+			case 4:
+			case 5:
+			case 6:
+			case 7:
+			case 8:
+			case 9:
+			case 10:
+				console_loglevel = ((keycode - 1));
+				wakeup_suspend();
+				break;
+#endif
+		}
+#endif
+		if (keycode == 57)
+			wakeup_suspend();
+
+		return;
+	}
+#endif
 #if defined(CONFIG_SPARC32) || defined(CONFIG_SPARC64)
 	if (keycode == KEY_A && sparc_l1_a_state) {
 		sparc_l1_a_state = 0;
diff -ruN linux-2.6.7/drivers/char/vt.c software-suspend-linux-2.6.7-rev10/drivers/char/vt.c
--- linux-2.6.7/drivers/char/vt.c	2004-06-18 12:44:00.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/char/vt.c	2004-07-08 14:37:07.000000000 +1000
@@ -150,11 +150,11 @@
 		    unsigned int cols, int do_clear);
 static void gotoxy(int currcons, int new_x, int new_y);
 static void save_cur(int currcons);
-static void reset_terminal(int currcons, int do_clear);
+void reset_terminal(int currcons, int do_clear);
 static void con_flush_chars(struct tty_struct *tty);
 static void set_vesa_blanking(char __user *p);
 static void set_cursor(int currcons);
-static void hide_cursor(int currcons);
+void hide_cursor(int currcons);
 static void console_callback(void *ignored);
 static void blank_screen_t(unsigned long dummy);
 
@@ -552,7 +552,7 @@
 	}
 }
 
-static void hide_cursor(int currcons)
+void hide_cursor(int currcons)
 {
 	if (currcons == sel_cons)
 		clear_selection();
@@ -889,7 +889,7 @@
  */
 static void gotoxy(int currcons, int new_x, int new_y)
 {
-	int min_y, max_y;
+	unsigned int min_y, max_y;
 
 	if (new_x < 0)
 		x = 0;
@@ -916,7 +916,7 @@
 }
 
 /* for absolute user moves, when decom is set */
-static void gotoxay(int currcons, int new_x, int new_y)
+static void gotoxay(int currcons, unsigned int new_x, unsigned int new_y)
 {
 	gotoxy(currcons, new_x, decom ? (top+new_y) : new_y);
 }
@@ -1431,7 +1431,7 @@
 	ESpalette };
 
 /* console_sem is held (except via vc_init()) */
-static void reset_terminal(int currcons, int do_clear)
+void reset_terminal(int currcons, int do_clear)
 {
 	top		= 0;
 	bottom		= video_num_lines;
diff -ruN linux-2.6.7/drivers/ieee1394/nodemgr.c software-suspend-linux-2.6.7-rev10/drivers/ieee1394/nodemgr.c
--- linux-2.6.7/drivers/ieee1394/nodemgr.c	2004-06-18 12:44:01.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/ieee1394/nodemgr.c	2004-07-08 14:37:07.000000000 +1000
@@ -19,7 +19,6 @@
 #include <linux/delay.h>
 #include <linux/pci.h>
 #include <linux/moduleparam.h>
-#include <linux/suspend.h>
 #include <asm/atomic.h>
 
 #include "ieee1394_types.h"
@@ -1482,7 +1481,7 @@
 		if (down_interruptible(&hi->reset_sem) ||
 		    down_interruptible(&nodemgr_serialize)) {
 			if (current->flags & PF_FREEZE) {
-				refrigerator(0);
+				refrigerator(PF_FREEZE);
 				continue;
 			}
 			printk("NodeMgr: received unexpected signal?!\n" );
@@ -1497,6 +1496,10 @@
 		for (i = 0; i < 4 ; i++) {
 			set_current_state(TASK_INTERRUPTIBLE);
 			if (schedule_timeout(HZ/16)) {
+				if (current->flags & PF_FREEZE) {
+					refrigerator(PF_FREEZE);
+					continue;
+				}
 				up(&nodemgr_serialize);
 				goto caught_signal;
 			}
diff -ruN linux-2.6.7/drivers/input/serio/serio.c software-suspend-linux-2.6.7-rev10/drivers/input/serio/serio.c
--- linux-2.6.7/drivers/input/serio/serio.c	2004-06-18 12:44:01.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/input/serio/serio.c	2004-07-08 14:37:07.000000000 +1000
@@ -40,7 +40,6 @@
 #include <linux/completion.h>
 #include <linux/sched.h>
 #include <linux/smp_lock.h>
-#include <linux/suspend.h>
 #include <linux/slab.h>
 
 MODULE_AUTHOR("Vojtech Pavlik <vojtech@ucw.cz>");
diff -ruN linux-2.6.7/drivers/macintosh/Kconfig software-suspend-linux-2.6.7-rev10/drivers/macintosh/Kconfig
--- linux-2.6.7/drivers/macintosh/Kconfig	2004-06-18 12:44:02.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/macintosh/Kconfig	2004-07-08 14:37:07.000000000 +1000
@@ -194,4 +194,8 @@
 	bool "Support for ANS LCD display"
 	depends on ADB_CUDA && PPC_PMAC
 
+config SOFTWARE_REPLACE_SLEEP
+	bool "Using Software suspend replace broken sleep function"
+	depends on SOFTWARE_SUSPEND2
+
 endmenu
diff -ruN linux-2.6.7/drivers/macintosh/via-pmu.c software-suspend-linux-2.6.7-rev10/drivers/macintosh/via-pmu.c
--- linux-2.6.7/drivers/macintosh/via-pmu.c	2004-04-17 03:21:06.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/macintosh/via-pmu.c	2004-07-08 14:37:07.000000000 +1000
@@ -2888,6 +2888,13 @@
 			return -EACCES;
 		if (sleep_in_progress)
 			return -EBUSY;
+#ifdef CONFIG_SOFTWARE_REPLACE_SLEEP
+		{
+		extern void software_suspend_pending(void);
+		software_suspend_pending();
+		return (0);
+		}
+#endif
 		sleep_in_progress = 1;
 		switch (pmu_kind) {
 		case PMU_OHARE_BASED:
diff -ruN linux-2.6.7/drivers/md/dm-crypt.c software-suspend-linux-2.6.7-rev10/drivers/md/dm-crypt.c
--- linux-2.6.7/drivers/md/dm-crypt.c	2004-05-19 22:10:27.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/md/dm-crypt.c	2004-07-08 14:37:07.000000000 +1000
@@ -758,7 +758,7 @@
 	if (!_crypt_io_pool)
 		return -ENOMEM;
 
-	_kcryptd_workqueue = create_workqueue("kcryptd");
+	_kcryptd_workqueue = create_workqueue("kcryptd", PF_NOFREEZE);
 	if (!_kcryptd_workqueue) {
 		r = -ENOMEM;
 		DMERR(PFX "couldn't create kcryptd");
diff -ruN linux-2.6.7/drivers/md/md.c software-suspend-linux-2.6.7-rev10/drivers/md/md.c
--- linux-2.6.7/drivers/md/md.c	2004-06-18 12:44:02.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/md/md.c	2004-07-08 14:37:07.000000000 +1000
@@ -36,7 +36,6 @@
 #include <linux/sysctl.h>
 #include <linux/devfs_fs_kernel.h>
 #include <linux/buffer_head.h> /* for invalidate_bdev */
-#include <linux/suspend.h>
 
 #include <linux/init.h>
 
@@ -2798,6 +2797,7 @@
 	 */
 
 	daemonize(thread->name, mdname(thread->mddev));
+	current->flags |= PF_NOFREEZE;
 
 	current->exit_signal = SIGCHLD;
 	allow_signal(SIGKILL);
@@ -2822,8 +2822,6 @@
 
 		wait_event_interruptible(thread->wqueue,
 					 test_bit(THREAD_WAKEUP, &thread->flags));
-		if (current->flags & PF_FREEZE)
-			refrigerator(PF_FREEZE);
 
 		clear_bit(THREAD_WAKEUP, &thread->flags);
 
diff -ruN linux-2.6.7/drivers/media/video/msp3400.c software-suspend-linux-2.6.7-rev10/drivers/media/video/msp3400.c
--- linux-2.6.7/drivers/media/video/msp3400.c	2004-06-18 12:44:02.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/media/video/msp3400.c	2004-07-08 14:37:07.000000000 +1000
@@ -739,6 +739,7 @@
 {
 	DECLARE_WAITQUEUE(wait, current);
 
+again:
 	add_wait_queue(&msp->wq, &wait);
 	if (!msp->rmmod) {
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -748,6 +749,12 @@
 			schedule_timeout(timeout);
 	}
 	remove_wait_queue(&msp->wq, &wait);
+	
+	if (current->flags & PF_FREEZE) {
+		refrigerator(PF_FREEZE);
+		goto again;
+	}
+
 	return msp->rmmod || signal_pending(current);
 }
 
diff -ruN linux-2.6.7/drivers/media/video/tvaudio.c software-suspend-linux-2.6.7-rev10/drivers/media/video/tvaudio.c
--- linux-2.6.7/drivers/media/video/tvaudio.c	2004-06-18 12:44:02.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/media/video/tvaudio.c	2004-07-08 14:37:07.000000000 +1000
@@ -285,6 +285,8 @@
 			schedule();
 		}
 		remove_wait_queue(&chip->wq, &wait);
+		if (current->flags & PF_FREEZE)
+			refrigerator(PF_FREEZE);
 		if (chip->done || signal_pending(current))
 			break;
 		dprintk("%s: thread wakeup\n", i2c_clientname(&chip->c));
diff -ruN linux-2.6.7/drivers/message/i2o/i2o_block.c software-suspend-linux-2.6.7-rev10/drivers/message/i2o/i2o_block.c
--- linux-2.6.7/drivers/message/i2o/i2o_block.c	2004-06-18 12:44:02.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/message/i2o/i2o_block.c	2004-07-08 14:37:07.000000000 +1000
@@ -615,6 +615,11 @@
 	{
 		if(down_interruptible(&i2ob_evt_sem))
 		{
+			if (current->flags & PF_FREEZE) {
+				refrigerator(PF_FREEZE);
+				continue;
+			}
+
 			evt_running = 0;
 			printk("exiting...");
 			break;
diff -ruN linux-2.6.7/drivers/message/i2o/i2o_core.c software-suspend-linux-2.6.7-rev10/drivers/message/i2o/i2o_core.c
--- linux-2.6.7/drivers/message/i2o/i2o_core.c	2004-06-18 12:44:02.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/message/i2o/i2o_core.c	2004-07-08 14:37:07.000000000 +1000
@@ -1024,6 +1024,11 @@
 	{
 		if(down_interruptible(&evt_sem))
 		{
+			if (current->flags & PF_FREEZE) {
+				refrigerator(PF_FREEZE);
+				continue;
+			}
+
 			dprintk(KERN_INFO "I2O event thread dead\n");
 			printk("exiting...");
 			evt_running = 0;
@@ -1192,6 +1197,11 @@
 		down_interruptible(&c->lct_sem);
 		if(signal_pending(current))
 		{
+			if (current->flags & PF_FREEZE) {
+				refrigerator(PF_FREEZE);
+				continue;
+			}
+
 			dprintk(KERN_ERR "%s: LCT thread dead\n", c->name);
 			c->lct_running = 0;
 			return 0;
diff -ruN linux-2.6.7/drivers/net/irda/sir_kthread.c software-suspend-linux-2.6.7-rev10/drivers/net/irda/sir_kthread.c
--- linux-2.6.7/drivers/net/irda/sir_kthread.c	2004-06-18 12:44:05.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/net/irda/sir_kthread.c	2004-07-08 14:37:07.000000000 +1000
@@ -19,7 +19,6 @@
 #include <linux/smp_lock.h>
 #include <linux/completion.h>
 #include <linux/delay.h>
-#include <linux/suspend.h>
 
 #include <net/irda/irda.h>
 
@@ -113,6 +112,7 @@
 	DECLARE_WAITQUEUE(wait, current);
 
 	daemonize("kIrDAd");
+	current->flags |= PF_NOFREEZE;
 
 	irda_rq_queue.thread = current;
 
@@ -135,10 +135,6 @@
 			__set_task_state(current, TASK_RUNNING);
 		remove_wait_queue(&irda_rq_queue.kick, &wait);
 
-		/* make swsusp happy with our thread */
-		if (current->flags & PF_FREEZE)
-			refrigerator(PF_FREEZE);
-
 		run_irda_queue();
 	}
 
diff -ruN linux-2.6.7/drivers/net/wan/sdlamain.c software-suspend-linux-2.6.7-rev10/drivers/net/wan/sdlamain.c
--- linux-2.6.7/drivers/net/wan/sdlamain.c	2004-03-16 09:20:04.000000000 +1100
+++ software-suspend-linux-2.6.7-rev10/drivers/net/wan/sdlamain.c	2004-07-08 14:37:07.000000000 +1000
@@ -240,7 +240,7 @@
 	printk(KERN_INFO "%s v%u.%u %s\n",
 		fullname, DRV_VERSION, DRV_RELEASE, copyright);
 
-	wanpipe_wq = create_workqueue("wanpipe_wq");
+	wanpipe_wq = create_workqueue("wanpipe_wq", 0);
 	if (!wanpipe_wq)
 		return -ENOMEM;
 
diff -ruN linux-2.6.7/drivers/pnp/pnpbios/core.c software-suspend-linux-2.6.7-rev10/drivers/pnp/pnpbios/core.c
--- linux-2.6.7/drivers/pnp/pnpbios/core.c	2004-06-18 12:44:07.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/pnp/pnpbios/core.c	2004-07-08 14:37:07.000000000 +1000
@@ -178,6 +178,8 @@
 		 */
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ*2);
+		if(current->flags & PF_FREEZE)
+			refrigerator(PF_FREEZE);
 		if(signal_pending(current))
 			break;
 
diff -ruN linux-2.6.7/drivers/s390/cio/device.c software-suspend-linux-2.6.7-rev10/drivers/s390/cio/device.c
--- linux-2.6.7/drivers/s390/cio/device.c	2004-06-18 12:44:07.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/s390/cio/device.c	2004-07-08 14:37:07.000000000 +1000
@@ -151,10 +151,11 @@
 	init_waitqueue_head(&ccw_device_init_wq);
 	atomic_set(&ccw_device_init_count, 0);
 
-	ccw_device_work = create_singlethread_workqueue("cio");
+	ccw_device_work = create_singlethread_workqueue("cio", 0);
 	if (!ccw_device_work)
 		return -ENOMEM; /* FIXME: better errno ? */
-	ccw_device_notify_work = create_singlethread_workqueue("cio_notify");
+	ccw_device_notify_work = create_singlethread_workqueue("cio_notify",
+			0);
 	if (!ccw_device_notify_work) {
 		ret = -ENOMEM; /* FIXME: better errno ? */
 		goto out_err;
diff -ruN linux-2.6.7/drivers/scsi/libata-core.c software-suspend-linux-2.6.7-rev10/drivers/scsi/libata-core.c
--- linux-2.6.7/drivers/scsi/libata-core.c	2004-06-18 12:44:09.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/scsi/libata-core.c	2004-07-08 14:37:07.000000000 +1000
@@ -3438,7 +3438,7 @@
 
 static int __init ata_init(void)
 {
-	ata_wq = create_workqueue("ata");
+	ata_wq = create_workqueue("ata", PF_NOFREEZE);
 	if (!ata_wq)
 		return -ENOMEM;
 
diff -ruN linux-2.6.7/drivers/serial/8250.c software-suspend-linux-2.6.7-rev10/drivers/serial/8250.c
--- linux-2.6.7/drivers/serial/8250.c	2004-05-19 22:10:35.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/drivers/serial/8250.c	2004-07-08 14:37:07.000000000 +1000
@@ -50,6 +50,12 @@
  */
 unsigned int share_irqs = SERIAL8250_SHARE_IRQS;
 
+#if defined(CONFIG_SERIAL_CORE_CONSOLE) && defined(CONFIG_SOFTWARE_SUSPEND2)
+#include <linux/suspend.h>
+#include <linux/suspend-debug.h>
+extern void wakeup_suspend(void);
+#endif
+
 /*
  * Debugging.
  */
@@ -821,6 +827,94 @@
 	serial_out(up, UART_IER, up->ier);
 }
 
+#if defined(CONFIG_SERIAL_CORE_CONSOLE) && defined(CONFIG_SOFTWARE_SUSPEND2)
+static inline void suspend_handle_character(unsigned char ch)
+{
+	extern void prepare_status(int printalways, int clearbar, const char *fmt, ...);
+	extern unsigned long suspend_action;
+	extern void request_abort_suspend(void);
+	extern void machine_restart(char * __unused);
+		
+	/*
+	 * I would like to be able to do the same as drivers/char/keyboard.c
+	 * here, and allow responding to the sanity check prompt over a serial
+	 * console. Unfortunately, it's one way communication at this point.
+	 * You can't even get into kdb because the serial port interrupts
+	 * aren't running yet.
+	 */
+
+	if (software_suspend_state & SOFTWARE_SUSPEND_SANITY_CHECK_PROMPT) {
+		if (ch == 32)
+			wakeup_suspend();
+		else if (ch == 67) {
+			software_suspend_state |= SOFTWARE_SUSPEND_CONTINUE_REQ;
+			wakeup_suspend();
+		} else
+			return;
+	}
+
+	if (ch >= 'A')
+		ch |= 32;
+
+	switch (ch) {
+		case 27:
+			/* Abort suspend */
+			if (TEST_ACTION_STATE(SUSPEND_CAN_CANCEL))
+				request_abort_suspend();
+			wakeup_suspend();
+			break;
+		case 49:
+			console_loglevel = 1;
+			wakeup_suspend();
+			break;
+		case 48:
+			console_loglevel = 0;
+			wakeup_suspend();
+			break;
+		case 32:
+			wakeup_suspend();
+			break;
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+		case 112:
+			/* During suspend, toggle pausing with Pause or Break if kdb active */
+			suspend_action ^= (1 << SUSPEND_PAUSE);
+			schedule_suspend_message(1);
+			wakeup_suspend();
+			break;
+		case 114:
+			/* Otherwise, if R pressed, toggle rebooting */
+			suspend_action ^= (1 << SUSPEND_REBOOT);
+			schedule_suspend_message(2);
+			wakeup_suspend();
+			break;
+		case 115:
+			/* Otherwise, if S pressed, toggle single-stepping */
+			suspend_action ^= (1 << SUSPEND_SINGLESTEP);
+			schedule_suspend_message(3);
+			wakeup_suspend();
+			break;
+		case 108:
+			/* Otherwise, if L pressed, toggle logging everything */
+			suspend_action ^= (1 << SUSPEND_LOGALL);
+			schedule_suspend_message(4);
+			wakeup_suspend();
+			break;
+		case 50:
+		case 51:
+		case 52:
+		case 53:
+		case 54:
+		case 55:
+			console_loglevel = ((ch - 48));
+			wakeup_suspend();
+			break;
+		default:
+			printk("Unhandled character %d.\n", ch);
+#endif
+	}
+}
+#endif /* #if defined(CONFIG_SERIAL_CORE_CONSOLE) && defined(CONFIG_SOFTWARE_SUSPEND2) */
+
 static _INLINE_ void
 receive_chars(struct uart_8250_port *up, int *status, struct pt_regs *regs)
 {
@@ -884,6 +978,16 @@
 		}
 		if (uart_handle_sysrq_char(&up->port, ch, regs))
 			goto ignore_char;
+
+#if defined(CONFIG_SERIAL_CORE_CONSOLE) && defined(CONFIG_SOFTWARE_SUSPEND2)
+		if (software_suspend_state & 
+			(SOFTWARE_SUSPEND_SANITY_CHECK_PROMPT |
+		     	 SOFTWARE_SUSPEND_RUNNING)) {
+			suspend_handle_character(ch);
+			goto ignore_char;
+		}
+#endif
+
 		if ((*status & up->port.ignore_status_mask) == 0) {
 			tty->flip.flag_buf_ptr++;
 			tty->flip.char_buf_ptr++;
diff -ruN linux-2.6.7/fs/aio.c software-suspend-linux-2.6.7-rev10/fs/aio.c
--- linux-2.6.7/fs/aio.c	2004-06-18 12:44:12.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/fs/aio.c	2004-07-08 14:37:07.000000000 +1000
@@ -68,7 +68,7 @@
 	kioctx_cachep = kmem_cache_create("kioctx", sizeof(struct kioctx),
 				0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL, NULL);
 
-	aio_wq = create_workqueue("aio");
+	aio_wq = create_workqueue("aio", PF_NOFREEZE);
 
 	pr_debug("aio_setup: sizeof(struct page) = %d\n", (int)sizeof(struct page));
 
diff -ruN linux-2.6.7/fs/buffer.c software-suspend-linux-2.6.7-rev10/fs/buffer.c
--- linux-2.6.7/fs/buffer.c	2004-06-18 12:44:12.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/fs/buffer.c	2004-07-08 14:37:07.000000000 +1000
@@ -253,6 +253,17 @@
  */
 int fsync_super(struct super_block *sb)
 {
+	int ret;
+
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	/* A safety net. During suspend, we might overwrite
+	 * memory containing filesystem info. We don't then
+	 * want to sync it to disk. */
+	if (unlikely(suspend_task))
+		return 0;
+#endif
+	current->flags |= PF_SYNCTHREAD;
+
 	sync_inodes_sb(sb, 0);
 	DQUOT_SYNC(sb);
 	lock_super(sb);
@@ -264,7 +275,10 @@
 	sync_blockdev(sb->s_bdev);
 	sync_inodes_sb(sb, 1);
 
-	return sync_blockdev(sb->s_bdev);
+	ret = sync_blockdev(sb->s_bdev);
+
+	current->flags &= ~PF_SYNCTHREAD;
+	return ret;
 }
 
 /*
@@ -275,12 +289,23 @@
 int fsync_bdev(struct block_device *bdev)
 {
 	struct super_block *sb = get_super(bdev);
+	int ret;
+
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (unlikely(suspend_task))
+		return 0;
+#endif
+	current->flags |= PF_SYNCTHREAD;
+
 	if (sb) {
 		int res = fsync_super(sb);
 		drop_super(sb);
+		current->flags &= ~PF_SYNCTHREAD;
 		return res;
 	}
-	return sync_blockdev(bdev);
+	ret = sync_blockdev(bdev);
+	current->flags &= ~PF_SYNCTHREAD;
+	return ret;
 }
 
 /**
@@ -360,6 +385,15 @@
  */
 static void do_sync(unsigned long wait)
 {
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	/* A safety net. During suspend, we might overwrite
+	 * memory containing filesystem info. We don't then
+	 * want to sync it to disk. */
+	if (unlikely(suspend_task))
+		return;
+#endif
+	current->flags |= PF_SYNCTHREAD;
+
 	wakeup_bdflush(0);
 	sync_inodes(0);		/* All mappings, inodes and their blockdevs */
 	DQUOT_SYNC(NULL);
@@ -371,6 +405,8 @@
 		printk("Emergency Sync complete\n");
 	if (unlikely(laptop_mode))
 		laptop_sync_completion();
+
+	current->flags &= ~PF_SYNCTHREAD;
 }
 
 asmlinkage long sys_sync(void)
@@ -396,6 +432,13 @@
 	struct super_block * sb;
 	int ret;
 
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (unlikely(suspend_task))
+		return 0;
+#endif
+
+	current->flags |= PF_SYNCTHREAD;
+
 	/* sync the inode to buffers */
 	write_inode_now(inode, 0);
 
@@ -408,6 +451,8 @@
 
 	/* .. finally sync the buffers to disk */
 	ret = sync_blockdev(sb->s_bdev);
+
+	current->flags &= ~PF_SYNCTHREAD;
 	return ret;
 }
 
@@ -417,6 +462,8 @@
 	struct address_space *mapping;
 	int ret, err;
 
+	current->flags |= PF_SYNCTHREAD;
+
 	ret = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -446,6 +493,7 @@
 out_putf:
 	fput(file);
 out:
+	current->flags &= ~PF_SYNCTHREAD;
 	return ret;
 }
 
@@ -455,6 +503,8 @@
 	struct address_space *mapping;
 	int ret, err;
 
+	current->flags |= PF_SYNCTHREAD;
+
 	ret = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -481,6 +531,7 @@
 out_putf:
 	fput(file);
 out:
+	current->flags &= PF_SYNCTHREAD;
 	return ret;
 }
 
@@ -1151,6 +1202,10 @@
 	 * async buffer heads in use.
 	 */
 	free_more_memory();
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (suspend_task == current->pid)
+		cleanup_finished_suspend_io();
+#endif
 	goto try_again;
 }
 
@@ -2884,7 +2939,7 @@
  *
  * try_to_free_buffers() is non-blocking.
  */
-static inline int buffer_busy(struct buffer_head *bh)
+inline int buffer_busy(struct buffer_head *bh)
 {
 	return atomic_read(&bh->b_count) |
 		(bh->b_state & ((1 << BH_Dirty) | (1 << BH_Lock)));
diff -ruN linux-2.6.7/fs/jbd/journal.c software-suspend-linux-2.6.7-rev10/fs/jbd/journal.c
--- linux-2.6.7/fs/jbd/journal.c	2004-06-18 12:44:16.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/fs/jbd/journal.c	2004-07-08 14:37:07.000000000 +1000
@@ -130,6 +130,7 @@
 	current_journal = journal;
 
 	daemonize("kjournald");
+	current->flags |= PF_SYNCTHREAD;
 
 	/* Set up an interval timer which can be used to trigger a
            commit wakeup after the commit interval expires */
diff -ruN linux-2.6.7/fs/jffs/intrep.c software-suspend-linux-2.6.7-rev10/fs/jffs/intrep.c
--- linux-2.6.7/fs/jffs/intrep.c	2004-02-06 15:27:48.000000000 +1100
+++ software-suspend-linux-2.6.7-rev10/fs/jffs/intrep.c	2004-07-08 14:37:07.000000000 +1000
@@ -3338,6 +3338,7 @@
 	D1(int i = 1);
 
 	daemonize("jffs_gcd");
+	current->flags |= PF_SYNCTHREAD;
 
 	c->gc_task = current;
 
@@ -3373,6 +3374,11 @@
 			siginfo_t info;
 			unsigned long signr = 0;
 
+			if (current->flags & PF_FREEZE) {
+				refrigerator(PF_FREEZE);
+				continue;
+			}
+
 			spin_lock_irq(&current->sighand->siglock);
 			signr = dequeue_signal(current, &current->blocked, &info);
 			spin_unlock_irq(&current->sighand->siglock);
diff -ruN linux-2.6.7/fs/jffs2/background.c software-suspend-linux-2.6.7-rev10/fs/jffs2/background.c
--- linux-2.6.7/fs/jffs2/background.c	2004-03-16 09:20:13.000000000 +1100
+++ software-suspend-linux-2.6.7-rev10/fs/jffs2/background.c	2004-07-08 14:37:07.000000000 +1000
@@ -15,7 +15,6 @@
 #include <linux/jffs2.h>
 #include <linux/mtd/mtd.h>
 #include <linux/completion.h>
-#include <linux/suspend.h>
 #include "nodelist.h"
 
 
diff -ruN linux-2.6.7/fs/jfs/jfs_logmgr.c software-suspend-linux-2.6.7-rev10/fs/jfs/jfs_logmgr.c
--- linux-2.6.7/fs/jfs/jfs_logmgr.c	2004-06-18 12:44:16.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/fs/jfs/jfs_logmgr.c	2004-07-08 14:37:07.000000000 +1000
@@ -2314,6 +2314,7 @@
 	struct lbuf *bp;
 
 	daemonize("jfsIO");
+	current->flags |= PF_SYNCTHREAD;
 
 	complete(&jfsIOwait);
 
diff -ruN linux-2.6.7/fs/jfs/jfs_txnmgr.c software-suspend-linux-2.6.7-rev10/fs/jfs/jfs_txnmgr.c
--- linux-2.6.7/fs/jfs/jfs_txnmgr.c	2004-06-18 12:44:16.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/fs/jfs/jfs_txnmgr.c	2004-07-08 14:37:07.000000000 +1000
@@ -47,7 +47,6 @@
 #include <linux/vmalloc.h>
 #include <linux/smp_lock.h>
 #include <linux/completion.h>
-#include <linux/suspend.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include "jfs_incore.h"
@@ -2730,6 +2729,7 @@
 	struct jfs_sb_info *sbi;
 
 	daemonize("jfsCommit");
+	current->flags |= PF_SYNCTHREAD;
 
 	complete(&jfsIOwait);
 
diff -ruN linux-2.6.7/fs/lockd/clntlock.c software-suspend-linux-2.6.7-rev10/fs/lockd/clntlock.c
--- linux-2.6.7/fs/lockd/clntlock.c	2004-05-19 22:10:39.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/fs/lockd/clntlock.c	2004-07-08 14:37:07.000000000 +1000
@@ -200,6 +200,7 @@
 	struct inode *inode;
 
 	daemonize("%s-reclaim", host->h_name);
+	current->flags |= PF_SYNCTHREAD;
 	allow_signal(SIGKILL);
 
 	/* This one ensures that our parent doesn't terminate while the
@@ -222,6 +223,8 @@
 
 		fl->fl_u.nfs_fl.flags &= ~NFS_LCK_RECLAIM;
 		nlmclnt_reclaim(host, fl);
+		if (current->flags & PF_FREEZE)
+			refrigerator(PF_FREEZE);
 		if (signalled())
 			break;
 		goto restart;
diff -ruN linux-2.6.7/fs/lockd/clntproc.c software-suspend-linux-2.6.7-rev10/fs/lockd/clntproc.c
--- linux-2.6.7/fs/lockd/clntproc.c	2004-05-19 22:10:39.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/fs/lockd/clntproc.c	2004-07-08 14:37:07.000000000 +1000
@@ -225,6 +225,8 @@
 	prepare_to_wait(queue, &wait, TASK_INTERRUPTIBLE);
 	if (!signalled ()) {
 		schedule_timeout(NLMCLNT_GRACE_WAIT);
+		if (current->flags & PF_FREEZE)
+			refrigerator(PF_FREEZE);
 		if (!signalled ())
 			status = 0;
 	}
diff -ruN linux-2.6.7/fs/lockd/svc.c software-suspend-linux-2.6.7-rev10/fs/lockd/svc.c
--- linux-2.6.7/fs/lockd/svc.c	2004-03-16 09:20:13.000000000 +1100
+++ software-suspend-linux-2.6.7-rev10/fs/lockd/svc.c	2004-07-08 14:37:07.000000000 +1000
@@ -112,6 +112,7 @@
 	up(&lockd_start);
 
 	daemonize("lockd");
+	current->flags |= PF_SYNCTHREAD;
 
 	/* Process request with signals blocked, but allow SIGKILL.  */
 	allow_signal(SIGKILL);
@@ -135,6 +136,9 @@
 	while ((nlmsvc_users || !signalled()) && nlmsvc_pid == current->pid) {
 		long timeout = MAX_SCHEDULE_TIMEOUT;
 
+		if (current->flags & PF_FREEZE)
+			refrigerator(PF_SYNCTHREAD);
+
 		if (signalled()) {
 			flush_signals(current);
 			if (nlmsvc_ops) {
diff -ruN linux-2.6.7/fs/nfsd/nfssvc.c software-suspend-linux-2.6.7-rev10/fs/nfsd/nfssvc.c
--- linux-2.6.7/fs/nfsd/nfssvc.c	2004-01-13 14:20:49.000000000 +1100
+++ software-suspend-linux-2.6.7-rev10/fs/nfsd/nfssvc.c	2004-07-08 14:37:07.000000000 +1000
@@ -181,6 +181,7 @@
 	lock_kernel();
 	daemonize("nfsd");
 	current->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
+	current->flags |= PF_SYNCTHREAD;
 
 	/* After daemonize() this kernel thread shares current->fs
 	 * with the init process. We need to create files with a
diff -ruN linux-2.6.7/fs/reiserfs/journal.c software-suspend-linux-2.6.7-rev10/fs/reiserfs/journal.c
--- linux-2.6.7/fs/reiserfs/journal.c	2004-06-18 12:44:17.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/fs/reiserfs/journal.c	2004-07-08 14:37:07.000000000 +1000
@@ -2420,7 +2420,7 @@
 
   reiserfs_mounted_fs_count++ ;
   if (reiserfs_mounted_fs_count <= 1)
-    commit_wq = create_workqueue("reiserfs");
+    commit_wq = create_workqueue("reiserfs", PF_SYNCTHREAD);
 
   INIT_WORK(&journal->j_work, flush_async_commits, p_s_sb);
   return 0 ;
diff -ruN linux-2.6.7/fs/xfs/linux-2.6/xfs_buf.c software-suspend-linux-2.6.7-rev10/fs/xfs/linux-2.6/xfs_buf.c
--- linux-2.6.7/fs/xfs/linux-2.6/xfs_buf.c	2004-06-18 12:44:17.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/fs/xfs/linux-2.6/xfs_buf.c	2004-07-08 14:37:07.000000000 +1000
@@ -51,7 +51,6 @@
 #include <linux/sysctl.h>
 #include <linux/proc_fs.h>
 #include <linux/workqueue.h>
-#include <linux/suspend.h>
 #include <linux/percpu.h>
 
 #include "xfs_linux.h"
@@ -1604,7 +1603,7 @@
 
 	/*  Set up the thread  */
 	daemonize("xfsbufd");
-	current->flags |= PF_MEMALLOC;
+	current->flags |= PF_MEMALLOC | PF_SYNCTHREAD;
 
 	pagebuf_daemon_task = current;
 	pagebuf_daemon_active = 1;
@@ -1728,11 +1727,11 @@
 {
 	int		rval;
 
-	pagebuf_logio_workqueue = create_workqueue("xfslogd");
+	pagebuf_logio_workqueue = create_workqueue("xfslogd", PF_SYNCTHREAD);
 	if (!pagebuf_logio_workqueue)
 		return -ENOMEM;
 
-	pagebuf_dataio_workqueue = create_workqueue("xfsdatad");
+	pagebuf_dataio_workqueue = create_workqueue("xfsdatad", PF_SYNCTHREAD);
 	if (!pagebuf_dataio_workqueue) {
 		destroy_workqueue(pagebuf_logio_workqueue);
 		return -ENOMEM;
diff -ruN linux-2.6.7/fs/xfs/linux-2.6/xfs_super.c software-suspend-linux-2.6.7-rev10/fs/xfs/linux-2.6/xfs_super.c
--- linux-2.6.7/fs/xfs/linux-2.6/xfs_super.c	2004-06-18 12:44:17.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/fs/xfs/linux-2.6/xfs_super.c	2004-07-08 14:37:07.000000000 +1000
@@ -385,6 +385,7 @@
 	int			error;
 
 	daemonize("xfssyncd");
+	current->flags |= PF_SYNCTHREAD;
 
 	vfsp->vfs_sync_task = current;
 	wmb();
diff -ruN linux-2.6.7/include/asm-i386/cpufeature.h software-suspend-linux-2.6.7-rev10/include/asm-i386/cpufeature.h
--- linux-2.6.7/include/asm-i386/cpufeature.h	2004-03-16 09:20:15.000000000 +1100
+++ software-suspend-linux-2.6.7-rev10/include/asm-i386/cpufeature.h	2004-07-08 14:37:07.000000000 +1000
@@ -88,6 +88,7 @@
 #define cpu_has_vme		boot_cpu_has(X86_FEATURE_VME)
 #define cpu_has_de		boot_cpu_has(X86_FEATURE_DE)
 #define cpu_has_pse		boot_cpu_has(X86_FEATURE_PSE)
+#define cpu_has_pse36		boot_cpu_has(X86_FEATURE_PSE36)
 #define cpu_has_tsc		boot_cpu_has(X86_FEATURE_TSC)
 #define cpu_has_pae		boot_cpu_has(X86_FEATURE_PAE)
 #define cpu_has_pge		boot_cpu_has(X86_FEATURE_PGE)
diff -ruN linux-2.6.7/include/asm-i386/tlbflush.h software-suspend-linux-2.6.7-rev10/include/asm-i386/tlbflush.h
--- linux-2.6.7/include/asm-i386/tlbflush.h	2004-01-13 14:23:55.000000000 +1100
+++ software-suspend-linux-2.6.7-rev10/include/asm-i386/tlbflush.h	2004-07-08 14:37:07.000000000 +1000
@@ -82,6 +82,7 @@
 #define flush_tlb() __flush_tlb()
 #define flush_tlb_all() __flush_tlb_all()
 #define local_flush_tlb() __flush_tlb()
+#define local_flush_tlb_all() __flush_tlb_all();
 
 static inline void flush_tlb_mm(struct mm_struct *mm)
 {
@@ -114,6 +115,10 @@
 extern void flush_tlb_current_task(void);
 extern void flush_tlb_mm(struct mm_struct *);
 extern void flush_tlb_page(struct vm_area_struct *, unsigned long);
+extern void do_flush_tlb_all(void * info);
+
+#define local_flush_tlb_all() \
+	do_flush_tlb_all(NULL);
 
 #define flush_tlb()	flush_tlb_current_task()
 
diff -ruN linux-2.6.7/include/asm-ppc/suspend.h software-suspend-linux-2.6.7-rev10/include/asm-ppc/suspend.h
--- linux-2.6.7/include/asm-ppc/suspend.h	1970-01-01 10:00:00.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/include/asm-ppc/suspend.h	2004-07-08 14:37:07.000000000 +1000
@@ -0,0 +1,14 @@
+#ifndef _PPC_SUSPEND_H
+#define _PPC_SUSPEND_H
+
+static inline void flush_tlb_all(void)
+{
+	/* Flush all TLBs */
+	__asm__ __volatile__("lis 4, 0x1000");
+	__asm__ __volatile__("1: addic. 4,4,-0x1000");
+	__asm__ __volatile__("tlbie 4");
+	__asm__ __volatile__("blt 1b");
+	__asm__ __volatile__("sync");
+}
+
+#endif
diff -ruN linux-2.6.7/include/linux/kthread.h software-suspend-linux-2.6.7-rev10/include/linux/kthread.h
--- linux-2.6.7/include/linux/kthread.h	2004-07-08 12:03:28.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/include/linux/kthread.h	2004-07-08 14:37:07.000000000 +1000
@@ -25,20 +25,26 @@
  */
 struct task_struct *kthread_create(int (*threadfn)(void *data),
 				   void *data,
+				   unsigned long freezer_flags,
 				   const char namefmt[], ...);
 
 /**
  * kthread_run: create and wake a thread.
  * @threadfn: the function to run until signal_pending(current).
  * @data: data ptr for @threadfn.
+ * @freezer_flags: process flags that should be used for freezing.
+ * 	PF_SYNCTHREAD if needed for syncing data to disk.
+ * 	PF_NOFREEZE if also needed for writing the image.
+ * 	0 otherwise.
  * @namefmt: printf-style name for the thread.
  *
  * Description: Convenient wrapper for kthread_create() followed by
  * wake_up_process().  Returns the kthread, or ERR_PTR(-ENOMEM). */
-#define kthread_run(threadfn, data, namefmt, ...)			   \
+#define kthread_run(threadfn, data, freezer_flags, namefmt, ...)	   \
 ({									   \
 	struct task_struct *__k						   \
-		= kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \
+		= kthread_create(threadfn, data, freezer_flags, 	   \
+			namefmt, ## __VA_ARGS__);			   \
 	if (!IS_ERR(__k))						   \
 		wake_up_process(__k);					   \
 	__k;								   \
diff -ruN linux-2.6.7/include/linux/pm.h software-suspend-linux-2.6.7-rev10/include/linux/pm.h
--- linux-2.6.7/include/linux/pm.h	2004-06-18 12:44:21.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/include/linux/pm.h	2004-07-08 14:37:07.000000000 +1000
@@ -245,6 +245,8 @@
 extern int device_power_down(u32 state);
 extern void device_power_up(void);
 extern void device_resume(void);
+extern void device_set_retain_state(struct device * dev);
+extern void device_flush_retain_state(void);
 
 
 #endif /* __KERNEL__ */
diff -ruN linux-2.6.7/include/linux/sched.h software-suspend-linux-2.6.7-rev10/include/linux/sched.h
--- linux-2.6.7/include/linux/sched.h	2004-06-18 12:44:21.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/include/linux/sched.h	2004-07-08 14:37:07.000000000 +1000
@@ -541,7 +541,7 @@
 #define PF_MEMDIE	0x00001000	/* Killed for out-of-memory */
 #define PF_FLUSHER	0x00002000	/* responsible for disk writeback */
 
-#define PF_FREEZE	0x00004000	/* this task should be frozen for suspend */
+#define PF_FREEZE	0x00004000	/* this task is being frozen for suspend now */
 #define PF_NOFREEZE	0x00008000	/* this thread should not be frozen */
 #define PF_FROZEN	0x00010000	/* frozen for system suspend */
 #define PF_FSTRANS	0x00020000	/* inside a filesystem transaction */
@@ -549,6 +549,10 @@
 #define PF_SWAPOFF	0x00080000	/* I am in swapoff */
 #define PF_LESS_THROTTLE 0x00100000	/* Throttle me less: I clean memory */
 #define PF_SYNCWRITE	0x00200000	/* I am doing a sync write */
+#define PF_REFRIGERATE	0x00400000	/* This task should be refrigerated */
+#define PF_SYNCTHREAD	0x00800000	/* this thread can start activity during the 
+					   early part of freezing processes */
+#define PF_FRIDGE_WAIT	0x01000000	/* this thread is currently doing I/O */
 
 #ifdef CONFIG_SMP
 #define SCHED_LOAD_SCALE	128UL	/* increase resolution of load */
@@ -1067,6 +1071,14 @@
 
 #endif /* CONFIG_SMP */
 
+#ifdef CONFIG_PM
+extern void refrigerator(unsigned long);
+extern unsigned int suspend_task;
+#else
+#define refrigerator(a)			do { } while(0)
+#define suspend_task (0)
+#endif
+
 #endif /* __KERNEL__ */
 
 #endif
diff -ruN linux-2.6.7/include/linux/suspend1.h software-suspend-linux-2.6.7-rev10/include/linux/suspend1.h
--- linux-2.6.7/include/linux/suspend1.h	1970-01-01 10:00:00.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/include/linux/suspend1.h	2004-07-08 14:37:07.000000000 +1000
@@ -0,0 +1,90 @@
+#ifndef _LINUX_SWSUSP_H
+#define _LINUX_SWSUSP_H
+
+#ifdef CONFIG_X86
+#include <asm/suspend.h>
+#endif
+#include <linux/swap.h>
+#include <linux/notifier.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/pm.h>
+
+#ifdef CONFIG_PM
+/* page backup entry */
+typedef struct pbe {
+	unsigned long address;		/* address of the copy */
+	unsigned long orig_address;	/* original address of page */
+	swp_entry_t swap_address;	
+	swp_entry_t dummy;		/* we need scratch space at 
+					 * end of page (see link, diskpage)
+					 */
+} suspend_pagedir_t;
+
+#define SWAP_FILENAME_MAXLENGTH	32
+
+struct suspend_header {
+	u32 version_code;
+	unsigned long num_physpages;
+	char machine[8];
+	char version[20];
+	int num_cpus;
+	int page_size;
+	suspend_pagedir_t *suspend_pagedir;
+	unsigned int num_pbes;
+};
+
+#define SUSPEND_PD_PAGES(x)     (((x)*sizeof(struct pbe))/PAGE_SIZE+1)
+   
+/* mm/vmscan.c */
+extern int shrink_mem(void);
+
+/* mm/page_alloc.c */
+extern void drain_local_pages(void);
+
+/* kernel/power/swsusp.c */
+extern int software_suspend(void);
+
+extern unsigned int nr_copy_pages __nosavedata;
+extern suspend_pagedir_t *pagedir_nosave __nosavedata;
+
+#else	/* CONFIG_SOFTWARE_SUSPEND */
+static inline int software_suspend(void)
+{
+	printk("Warning: fake suspend called\n");
+	return -EPERM;
+}
+#define software_resume()		do { } while(0)
+#endif	/* CONFIG_SOFTWARE_SUSPEND */
+
+
+#ifdef CONFIG_PM
+extern void refrigerator(unsigned long);
+extern int freeze_processes(void);
+extern void thaw_processes(void);
+
+extern int pm_prepare_console(void);
+extern void pm_restore_console(void);
+
+#else
+static inline void refrigerator(unsigned long flag)
+{
+
+}
+static inline int freeze_processes(void)
+{
+	return 0;
+}
+static inline void thaw_processes(void)
+{
+
+}
+#endif	/* CONFIG_PM */
+
+asmlinkage void do_magic(int is_resume);
+asmlinkage void do_magic_resume_1(void);
+asmlinkage void do_magic_resume_2(void);
+asmlinkage void do_magic_suspend_1(void);
+asmlinkage void do_magic_suspend_2(void);
+
+#endif /* _LINUX_SWSUSP_H */
diff -ruN linux-2.6.7/include/linux/suspend.h software-suspend-linux-2.6.7-rev10/include/linux/suspend.h
--- linux-2.6.7/include/linux/suspend.h	2004-05-19 22:10:47.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/include/linux/suspend.h	1970-01-01 10:00:00.000000000 +1000
@@ -1,90 +0,0 @@
-#ifndef _LINUX_SWSUSP_H
-#define _LINUX_SWSUSP_H
-
-#ifdef CONFIG_X86
-#include <asm/suspend.h>
-#endif
-#include <linux/swap.h>
-#include <linux/notifier.h>
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/pm.h>
-
-#ifdef CONFIG_PM
-/* page backup entry */
-typedef struct pbe {
-	unsigned long address;		/* address of the copy */
-	unsigned long orig_address;	/* original address of page */
-	swp_entry_t swap_address;	
-	swp_entry_t dummy;		/* we need scratch space at 
-					 * end of page (see link, diskpage)
-					 */
-} suspend_pagedir_t;
-
-#define SWAP_FILENAME_MAXLENGTH	32
-
-struct suspend_header {
-	u32 version_code;
-	unsigned long num_physpages;
-	char machine[8];
-	char version[20];
-	int num_cpus;
-	int page_size;
-	suspend_pagedir_t *suspend_pagedir;
-	unsigned int num_pbes;
-};
-
-#define SUSPEND_PD_PAGES(x)     (((x)*sizeof(struct pbe))/PAGE_SIZE+1)
-   
-/* mm/vmscan.c */
-extern int shrink_mem(void);
-
-/* mm/page_alloc.c */
-extern void drain_local_pages(void);
-
-/* kernel/power/swsusp.c */
-extern int software_suspend(void);
-
-extern unsigned int nr_copy_pages __nosavedata;
-extern suspend_pagedir_t *pagedir_nosave __nosavedata;
-
-#else	/* CONFIG_SOFTWARE_SUSPEND */
-static inline int software_suspend(void)
-{
-	printk("Warning: fake suspend called\n");
-	return -EPERM;
-}
-#define software_resume()		do { } while(0)
-#endif	/* CONFIG_SOFTWARE_SUSPEND */
-
-
-#ifdef CONFIG_PM
-extern void refrigerator(unsigned long);
-extern int freeze_processes(void);
-extern void thaw_processes(void);
-
-extern int pm_prepare_console(void);
-extern void pm_restore_console(void);
-
-#else
-static inline void refrigerator(unsigned long flag)
-{
-
-}
-static inline int freeze_processes(void)
-{
-	return 0;
-}
-static inline void thaw_processes(void)
-{
-
-}
-#endif	/* CONFIG_PM */
-
-asmlinkage void do_magic(int is_resume);
-asmlinkage void do_magic_resume_1(void);
-asmlinkage void do_magic_resume_2(void);
-asmlinkage void do_magic_suspend_1(void);
-asmlinkage void do_magic_suspend_2(void);
-
-#endif /* _LINUX_SWSUSP_H */
diff -ruN linux-2.6.7/include/linux/suspend-version-specific.h software-suspend-linux-2.6.7-rev10/include/linux/suspend-version-specific.h
--- linux-2.6.7/include/linux/suspend-version-specific.h	1970-01-01 10:00:00.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/include/linux/suspend-version-specific.h	2004-07-08 14:37:07.000000000 +1000
@@ -0,0 +1,133 @@
+/*
+ * Software Suspend header file.
+ *
+ * This file sets the major and minor version numbers of the version specific
+ * part of the Software Suspend patch. The major and minor numbers must match
+ * those of the core patch. The extra is updated as necessary for version
+ * specific changes.
+ */
+
+#ifndef SWSUSP_VERSION_SPECIFIC_REVISION
+#define SWSUSP_VERSION_SPECIFIC_REVISION 0x201
+#define SWSUSP_VERSION_SPECIFIC_REVISION_STRING "2.0.1"
+
+#ifdef CONFIG_BOOTSPLASH
+#include <linux/console.h>
+#include "../../drivers/video/console/fbcon.h"
+static inline struct splash_data * get_splash_data(int consolenr)
+{
+	BUG_ON(consolenr >= MAX_NR_CONSOLES);
+
+	if (vc_cons[consolenr].d)
+		return vc_cons[consolenr].d->vc_splash_data;
+	
+	return NULL;
+}
+#endif
+
+/* --- Definitions for swapwriter */
+#include <linux/blkdev.h>
+#include <linux/swapops.h>
+#include <linux/buffer_head.h>
+
+#define DEVICE_ID_TYPE dev_t
+#define DEVICE_BLOCK_TYPE struct block_device *
+#define DEVICE_BLOCK_NONE NULL
+#define SYS_IO_STRUCT struct bio
+#define SYS_ZONE_TYPE long
+#define SIG_BDEV_START 2
+#define SWP_OFFSET swp_offset
+#define SWP_TYPE swp_type
+#define SWP_ENTRY swp_entry
+#define UNUSED_SWAP_ENTRY(i) (!swap_info[i].swap_file)
+#define SWAP_FILE_INODE(i) swap_info[i].swap_file->f_dentry->d_inode
+#define SWAP_IS_PARTITION(i) (S_ISBLK(SWAP_FILE_INODE(i)->i_mode))
+#define SWAP_DEVICE_ID(i) (SWAP_FILE_INODE(i)->i_rdev)
+#define SWAP_DEVICE_BDEV(i) (swap_info[i].bdev)
+#define BDEV_TO_DEVICE_ID(bdev) ((bdev)->bd_dev)
+#define SWAP_BLOCKSIZE(bdev) (block_size(bdev))
+#define RESUME_BDEV(i) swap_info[i].bdev
+extern void kblockd_flush(void);
+#define RUN_IO do { \
+	int device; \
+	for (device = 0; device < MAX_SWAPFILES; device++) \
+		if (SWAP_DEVICE_BDEV(device)) \
+			generic_unplug_device(bdev_get_queue(SWAP_DEVICE_BDEV(device))); \
+	/* kblockd_flush(); io_schedule(); */ \
+	} while(0)
+#define SYNC_IO do { RUN_IO; schedule(); } while(0)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,3)
+#define OPEN_BY_DEVNUM(device, mode) open_by_devnum(device, mode)
+#else
+#define OPEN_BY_DEVNUM(device, mode) \
+			open_by_devnum(device, mode, BDEV_RAW)
+#endif
+
+/* --- End of definitions for swapwriter */
+
+#define NUM_CPUS num_online_cpus()
+#define MIN min
+#define MAX max
+#define PROCESS_SIG_MASK(p) &p->sighand->siglock
+#define RECALC_SIGPENDING recalc_sigpending()
+#define FOR_EACH_THREAD_TASK_STRUCTS *p, *g
+#define FOR_EACH_THREAD_START do_each_thread(g, p)
+#define FOR_EACH_THREAD_END while_each_thread(g, p);
+#define THREAD_PREEMPT_COUNT preempt_count()
+#define WAKE_UP(p) signal_wake_up(p, 0)
+#define FREE_AREA_TYPE struct free_area
+#define ZONE_TYPE struct zone
+#define STORAGE_UNSUSPEND
+#define STORAGE_SUSPEND
+#define EAT_MEMORY_FLAGS GFP_ATOMIC | __GFP_NOWARN
+#define CPU0_MASK (cpumask_of_cpu(0))
+
+extern asmlinkage ssize_t sys_write(unsigned int fd, const char __user * buf, size_t count);
+
+#define INACTIVE_LIST_FOR_EACH(procedure) \
+do { \
+ if (zone->nr_inactive) { \
+  struct list_head * entry = zone->inactive_list.prev; \
+  while (entry != &zone->inactive_list) { \
+   struct page * page = list_entry(entry, struct page, lru); \
+   { \
+    procedure(page); \
+   } \
+   entry = entry->prev; \
+  } \
+ } \
+} while(0)
+
+#define ACTIVE_LIST_FOR_EACH(procedure) \
+do { \
+ if (zone->nr_active) { \
+  struct list_head * entry = zone->active_list.prev; \
+  while (entry != &zone->active_list) { \
+   struct page * page; \
+   page = list_entry(entry, struct page, lru); \
+   procedure(page); \
+   entry = entry->prev; \
+  } \
+ } \
+} while(0)
+
+extern void disable_pcp_lists(void);
+extern void enable_pcp_lists(void);
+
+#ifdef CONFIG_HIGHMEM
+#define KMAP_ATOMIC(a) \
+	(((highmem_start_page) && (a < highmem_start_page)) ? \
+	 page_address(a) : kmap_atomic(a, KM_USER1))
+#define KUNMAP_ATOMIC(a) \
+	do { \
+		if ((highmem_start_page) && (a >= highmem_start_page)) \
+			kunmap_atomic(a, KM_USER1); \
+	} while(0)
+#else
+#define KMAP_ATOMIC(a) page_address(a)
+#define KUNMAP_ATOMIC(a) do { } while(0)
+#endif
+
+#define SWAP_FILE_STRUCT file
+
+#endif
diff -ruN linux-2.6.7/include/linux/workqueue.h software-suspend-linux-2.6.7-rev10/include/linux/workqueue.h
--- linux-2.6.7/include/linux/workqueue.h	2004-05-19 22:10:47.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/include/linux/workqueue.h	2004-07-08 14:37:07.000000000 +1000
@@ -51,9 +51,10 @@
 	} while (0)
 
 extern struct workqueue_struct *__create_workqueue(const char *name,
-						    int singlethread);
-#define create_workqueue(name) __create_workqueue((name), 0)
-#define create_singlethread_workqueue(name) __create_workqueue((name), 1)
+						    int singlethread,
+						    unsigned long freezer_flag);
+#define create_workqueue(name, flags) __create_workqueue((name), 0, flags)
+#define create_singlethread_workqueue(name, flags) __create_workqueue((name), 1, flags)
 
 extern void destroy_workqueue(struct workqueue_struct *wq);
 
diff -ruN linux-2.6.7/init/do_mounts.c software-suspend-linux-2.6.7-rev10/init/do_mounts.c
--- linux-2.6.7/init/do_mounts.c	2004-05-19 22:10:47.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/init/do_mounts.c	2004-07-08 14:37:07.000000000 +1000
@@ -52,7 +52,7 @@
 __setup("ro", readonly);
 __setup("rw", readwrite);
 
-static dev_t __init try_name(char *name, int part)
+static dev_t try_name(char *name, int part)
 {
 	char path[64];
 	char buf[32];
@@ -134,16 +134,21 @@
  *	is mounted on rootfs /sys.
  */
 
-dev_t __init name_to_dev_t(char *name)
+dev_t name_to_dev_t(char *name)
 {
 	char s[32];
 	char *p;
 	dev_t res = 0;
-	int part;
+	int part, mount_result;
 
 #ifdef CONFIG_SYSFS
 	sys_mkdir("/sys", 0700);
-	if (sys_mount("sysfs", "/sys", "sysfs", 0, NULL) < 0)
+	/* 
+	 * When changing resume2 parameter for Software Suspend, sysfs may
+	 * already be mounted. 
+	 */
+	mount_result = sys_mount("sysfs", "/sys", "sysfs", 0, NULL);
+	if (mount_result < 0 && mount_result != -EBUSY)
 		goto out;
 #endif
 
@@ -195,7 +200,8 @@
 	res = try_name(s, part);
 done:
 #ifdef CONFIG_SYSFS
-	sys_umount("/sys", 0);
+	if (mount_result >= 0)
+		sys_umount("/sys", 0);
 out:
 	sys_rmdir("/sys");
 #endif
diff -ruN linux-2.6.7/kernel/exit.c software-suspend-linux-2.6.7-rev10/kernel/exit.c
--- linux-2.6.7/kernel/exit.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/exit.c	2004-07-08 14:37:07.000000000 +1000
@@ -12,6 +12,7 @@
 #include <linux/module.h>
 #include <linux/completion.h>
 #include <linux/personality.h>
+#include <linux/suspend.h>
 #include <linux/tty.h>
 #include <linux/namespace.h>
 #include <linux/security.h>
@@ -777,6 +778,8 @@
 		panic("Attempted to kill init!");
 	if (tsk->io_context)
 		exit_io_context();
+	if (suspend_task)
+		refrigerator(PF_FREEZE);
 	tsk->flags |= PF_EXITING;
 	del_timer_sync(&tsk->real_timer);
 
diff -ruN linux-2.6.7/kernel/fork.c software-suspend-linux-2.6.7-rev10/kernel/fork.c
--- linux-2.6.7/kernel/fork.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/fork.c	2004-07-08 14:37:07.000000000 +1000
@@ -36,6 +36,7 @@
 #include <linux/mount.h>
 #include <linux/audit.h>
 #include <linux/rmap.h>
+#include <linux/suspend.h>
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -1175,6 +1176,11 @@
 	int trace = 0;
 	long pid;
 
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (unlikely(suspend_task))
+		refrigerator(0);
+#endif
+
 	if (unlikely(current->ptrace)) {
 		trace = fork_traceflag (clone_flags);
 		if (trace)
diff -ruN linux-2.6.7/kernel/kmod.c software-suspend-linux-2.6.7-rev10/kernel/kmod.c
--- linux-2.6.7/kernel/kmod.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/kmod.c	2004-07-08 14:37:07.000000000 +1000
@@ -275,7 +275,7 @@
 
 static __init int usermodehelper_init(void)
 {
-	khelper_wq = create_singlethread_workqueue("khelper");
+	khelper_wq = create_singlethread_workqueue("khelper", 0);
 	BUG_ON(!khelper_wq);
 	return 0;
 }
diff -ruN linux-2.6.7/kernel/kthread.c software-suspend-linux-2.6.7-rev10/kernel/kthread.c
--- linux-2.6.7/kernel/kthread.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/kthread.c	2004-07-08 14:37:07.000000000 +1000
@@ -19,6 +19,7 @@
 	/* Information passed to kthread() from keventd. */
 	int (*threadfn)(void *data);
 	void *data;
+	unsigned long freezer_flags;
 	struct completion started;
 
 	/* Result passed back to kthread_create() from keventd. */
@@ -81,6 +82,9 @@
 	/* By default we can run anywhere, unlike keventd. */
 	set_cpus_allowed(current, mask);
 
+	/* Set our freezer flags */
+	current->flags |= create->freezer_flags;
+
 	/* OK, tell user we're spawned, wait for stop or wakeup */
 	__set_current_state(TASK_INTERRUPTIBLE);
 	complete(&create->started);
@@ -116,6 +120,7 @@
 
 struct task_struct *kthread_create(int (*threadfn)(void *data),
 				   void *data,
+				   unsigned long freezer_flags,
 				   const char namefmt[],
 				   ...)
 {
@@ -124,6 +129,7 @@
 
 	create.threadfn = threadfn;
 	create.data = data;
+	create.freezer_flags = freezer_flags;
 	init_completion(&create.started);
 	init_completion(&create.done);
 
diff -ruN linux-2.6.7/kernel/module.c software-suspend-linux-2.6.7-rev10/kernel/module.c
--- linux-2.6.7/kernel/module.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/module.c	2004-07-08 14:37:07.000000000 +1000
@@ -2051,6 +2051,33 @@
 	printk("\n");
 }
 
+#define MODLIST_SIZE 4096
+
+void print_module_list(void)
+{
+	static char modlist[MODLIST_SIZE];
+	struct module *mod;
+	int pos = 0;
+
+	list_for_each_entry(mod, &modules, list)
+		if (mod->name)
+			pos += snprintf(modlist+pos, MODLIST_SIZE-pos-1, 
+					"%s ", mod->name);
+	printk("%s\n",modlist);
+}
+
+int print_module_list_to_buffer(char * buffer, int size)
+{
+	struct module *mod;
+	int pos = 0;
+
+	list_for_each_entry(mod, &modules, list)
+		if (mod->name)
+			pos += snprintf(buffer+pos, size-pos-1, 
+					"%s ", mod->name);
+	return pos;
+}
+
 #ifdef CONFIG_MODVERSIONS
 /* Generate the signature for struct module here, too, for modversions. */
 void struct_module(struct module *mod) { return; }
diff -ruN linux-2.6.7/kernel/panic.c software-suspend-linux-2.6.7-rev10/kernel/panic.c
--- linux-2.6.7/kernel/panic.c	2004-03-16 09:20:22.000000000 +1100
+++ software-suspend-linux-2.6.7-rev10/kernel/panic.c	2004-07-08 14:37:07.000000000 +1000
@@ -18,6 +18,7 @@
 #include <linux/sysrq.h>
 #include <linux/syscalls.h>
 #include <linux/interrupt.h>
+#include <linux/suspend.h>
 #include <linux/nmi.h>
 
 int panic_timeout;
@@ -64,6 +65,10 @@
 		printk(KERN_EMERG "In interrupt handler - not syncing\n");
 	else if (!current->pid)
 		printk(KERN_EMERG "In idle task - not syncing\n");
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	else if (suspend_task)
+		printk(KERN_EMERG "In software suspend - not syncing.\n");
+#endif
 	else
 		sys_sync();
 	bust_spinlocks(0);
diff -ruN linux-2.6.7/kernel/power/block_io.c software-suspend-linux-2.6.7-rev10/kernel/power/block_io.c
--- linux-2.6.7/kernel/power/block_io.c	1970-01-01 10:00:00.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/power/block_io.c	2004-07-08 14:37:07.000000000 +1000
@@ -0,0 +1,544 @@
+/*
+ * block_io.c
+ *
+ * Copyright 2004 Nigel Cunningham <ncunningham@linuxmail.org>
+ *
+ * Distributed under GPLv2.
+ * 
+ * This file contains block io functions for suspend2. These are
+ * used by the swapwriter and it is planned that they will also
+ * be used by the NFSwriter.
+ *
+ */
+
+#include <linux/suspend-common.h>
+#include "block_io.h"
+
+/* Bits in struct io_info->flags */
+#define IO_WRITING 1
+#define IO_RESTORE_PAGE_PROT 2
+#define IO_AWAITING_READ 3
+#define IO_AWAITING_WRITE 4
+#define IO_CLEANUP_IN_PROGRESS 5
+#define IO_HANDLE_PAGE_PROT 6
+
+/*
+ * ---------------------------------------------------------------
+ *
+ *     IO in progress information storage and helpers
+ *
+ * ---------------------------------------------------------------
+ */
+
+struct io_info {
+	SYS_IO_STRUCT * sys_struct;
+	SYS_ZONE_TYPE blocks[PAGE_SIZE/512];
+	struct page * buffer_page;
+	struct page * data_page;
+	unsigned long flags;
+	DEVICE_BLOCK_TYPE dev;
+	int blocks_used;
+	int block_size;
+	struct list_head list;
+	int readahead_index;
+};
+
+static LIST_HEAD(ioinfo_free);
+static LIST_HEAD(ioinfo_ready_for_cleanup);
+static LIST_HEAD(ioinfo_busy);
+static spinlock_t ioinfo_lists_lock = SPIN_LOCK_UNLOCKED;
+
+/* [Max] number of I/O operations pending */
+static int outstanding_io = 0;
+static int max_outstanding_io = 0;
+static int buffer_allocs, buffer_frees;
+
+/* [Max] number of pages used for above struct */
+static int infopages = 0;
+static int maxinfopages = 0;
+
+/*
+ * cleanup_one
+ * 
+ * Description: Clean up after completing I/O on a page.
+ * Arguments:	struct io_info:	Data for I/O to be completed.
+ */
+static inline void cleanup_one(struct io_info * io_info)
+{
+	struct page * buffer_page;
+	struct page * data_page;
+	char *buffer_address, *data_address;
+	int reading;
+
+	buffer_page = io_info->buffer_page;
+	data_page = io_info->data_page;
+
+	/* 
+	 * Already being cleaned up? Can't happen while we're single
+	 * threaded, but a good check for later.
+	 */
+	
+	if (test_and_set_bit(IO_CLEANUP_IN_PROGRESS, &io_info->flags))
+		return;
+
+	reading = test_bit(IO_AWAITING_READ, &io_info->flags);
+	printlog(SUSPEND_IO, SUSPEND_HIGH, "Cleanup IO: [%p]\n", 
+		io_info);
+
+	if (reading) {
+		/*
+		 * Copy the page we read into the buffer our caller provided.
+		 */
+		data_address = (char *) kmap(data_page);
+		buffer_address = (char *) kmap(buffer_page);
+		memcpy(data_address, buffer_address, PAGE_SIZE);
+		flush_dcache_page(data_page);
+		kunmap(data_page);
+		kunmap(buffer_page);
+	
+	}
+
+	/* Sanity check */
+	if (page_count(buffer_page) != 2)
+		printk(KERN_EMERG "Cleanup IO: Page count is %d. Not good!\n",
+				page_count(buffer_page));
+	put_page(buffer_page);
+	__free_pages(buffer_page, 0);
+	buffer_frees++;
+	
+	outstanding_io--;
+	bio_put(io_info->sys_struct);
+	io_info->sys_struct = NULL;
+	io_info->flags = 0;
+}
+
+/* 
+ * ioinfo_cleanup_one
+ *
+ * Description:	Clean up a completed I/O, if one is ready.
+ * Returns:	Returns pointer to the page which was cleaned up on success,
+ * 		-ENODATA if none ready for cleanup.
+ */
+
+static struct io_info * ioinfo_cleanup_one(void)
+{
+	struct io_info * this;
+	int readahead_index;
+	unsigned long flags;
+
+	/* Anything to do? */
+	if (list_empty(&ioinfo_ready_for_cleanup))
+		return ERR_PTR(-ENODATA);
+
+	/* 
+	 * Yes. Get our target and remove it from the list to ensure no one
+	 * else duplicates our labours.
+	 */
+	spin_lock_irqsave(&ioinfo_lists_lock, flags);
+	this = list_entry(ioinfo_ready_for_cleanup.next, struct io_info, list);
+	list_del(&this->list);
+	spin_unlock_irqrestore(&ioinfo_lists_lock, flags);
+
+	/*
+	 * If this I/O was a readahead, remember its index and reset it.
+	 */
+	readahead_index = this->readahead_index;
+	this->readahead_index = -1;
+
+	/*
+	 * Do the cleanup.
+	 */
+	cleanup_one(this);
+
+	/*
+	 * Record the readahead as done.
+	 */
+	if (readahead_index > -1) {
+		int index = readahead_index/(8 * sizeof(unsigned long));
+		int bit = readahead_index - (index * 8 * sizeof(unsigned long));
+		spin_lock_irqsave(&suspend_readahead_flags_lock, flags);
+		set_bit(bit, &suspend_readahead_flags[index]);
+		spin_unlock_irqrestore(&suspend_readahead_flags_lock, flags);
+	}
+
+	/*
+	 * Add it to the free list.
+	 */
+	spin_lock_irqsave(&ioinfo_lists_lock, flags);
+	list_add_tail(&this->list, &ioinfo_free);
+	spin_unlock_irqrestore(&ioinfo_lists_lock, flags);
+	return this;
+}
+
+/*
+ * get_io_info_struct
+ *
+ * Description:	Get an I/O struct.
+ * Returns:	Pointer to the struct prepared for use.
+ */
+static struct io_info * get_io_info_struct(void)
+{
+	unsigned long newpage = 0, flags;
+	struct io_info * this = NULL;
+	int iteration = 0, remaining = 0;
+
+	do {
+		if (!(iteration%8))
+			RUN_IO;
+		iteration++;
+	
+		/* We clean up an IO info struct if possible */
+		ioinfo_cleanup_one();
+
+		/* Have we reached our number-of-IOs-activate-at-one limit? */
+		if ((max_async_ios) && (outstanding_io >= max_async_ios))
+			continue;
+
+		/* Can start a new I/O. Is there a free one? */
+		if (!list_empty(&ioinfo_free)) {
+			/* Yes. Grab it. */
+			spin_lock_irqsave(&ioinfo_lists_lock, flags);
+			break;
+		}
+
+		/* No. Need to allocate a new page for I/O info structs. */
+		newpage = get_zeroed_page(GFP_ATOMIC);
+		if (!newpage)
+			continue;
+
+		printlog(SUSPEND_MEMORY, SUSPEND_VERBOSE,
+				"[NewIOPage %lx]", newpage);
+		infopages++;
+		if (infopages > maxinfopages)
+			maxinfopages++;
+
+		/* Prepare the new page for use. */
+		this = (struct io_info *) newpage;
+		remaining = PAGE_SIZE;
+		spin_lock_irqsave(&ioinfo_lists_lock, flags);
+		while (remaining >= (sizeof(struct io_info))) {
+			list_add_tail(&this->list, &ioinfo_free);
+			this = (struct io_info *) (((char *) this) + 
+					sizeof(struct io_info));
+			remaining -= sizeof(struct io_info);
+		}
+		break;
+	} while (1);
+
+	/* We have an I/O info struct. Move it to the busy list. */
+	this = list_entry(ioinfo_free.next, struct io_info, list);
+	list_move_tail(&this->list, &ioinfo_busy);
+	spin_unlock_irqrestore(&ioinfo_lists_lock, flags);
+	return this;
+}
+
+/*
+ * finish_all_io
+ *
+ * Description:	Finishes all IO and frees all IO info struct pages.
+ */
+void finish_all_io(void)
+{
+	struct io_info * this, * next = NULL;
+	unsigned long flags;
+
+	/* Wait for all I/O to complete. */
+	while (!list_empty(&ioinfo_busy))
+		SYNC_IO;
+
+	/* Clean them all up. */
+	do { } while (!IS_ERR(ioinfo_cleanup_one()));
+
+	/*
+	 * We're single threaded and all I/O is completed, so we shouldn't
+	 * need to use the spinlock, but let's be safe.
+	 */
+	spin_lock_irqsave(&ioinfo_lists_lock, flags);
+	
+	/* 
+	 * Two stages, to avoid using freed pages.
+	 *
+	 * First free all io_info structs on a page except the first.
+	 */
+	list_for_each_entry_safe(this, next, &ioinfo_free, list) {
+		if (((unsigned long) this) & ~PAGE_MASK)
+			list_del(&this->list);
+	}
+
+	/* 
+	 * Now we have only one reference to each page, and can safely
+	 * free pages, knowing we're not going to be trying to access the
+	 * same page after freeing it.
+	 */
+	list_for_each_entry_safe(this, next, &ioinfo_free, list) {
+		list_del(&this->list);
+		free_pages((unsigned long) this, 0);
+		printlog(SUSPEND_MEMORY, SUSPEND_VERBOSE,
+				"[FreedIOPage %lx]", this);
+	}
+	
+	spin_unlock_irqrestore(&ioinfo_lists_lock, flags);
+}
+
+/*
+ * wait_on_one_page
+ *
+ * Description:	Wait for a particular I/O to complete.
+ */
+static void wait_on_one_page(struct io_info * io_info)
+{
+	do {
+		SYNC_IO;
+	} while (ioinfo_cleanup_one() != io_info);
+}
+
+/*
+ * reset_io_stats
+ *
+ * Description:	Reset all our sanity-checking statistics.
+ */
+void inline reset_io_stats(void)
+{
+	max_outstanding_io = outstanding_io = 0;
+	maxinfopages = infopages = 0;
+	buffer_allocs = buffer_frees = 0;
+}
+
+/*
+ * check_io_stats
+ *
+ * Description:	Check that our statistics look right and print
+ * 		any debugging info wanted.
+ */
+void suspend_check_io_stats(void)
+{
+	if (outstanding_io)
+		printnolog(SUSPEND_IO, SUSPEND_MEDIUM, 0,
+			"Outstanding_io after writing is %d.\n",
+			outstanding_io);
+	printnolog(SUSPEND_IO, SUSPEND_LOW, 0,
+			"Maximum outstanding_io was %d.\n",
+			max_outstanding_io);
+	if (infopages)
+		printnolog(SUSPEND_IO, SUSPEND_MEDIUM, 0,
+				"Info pages is %d.\n",
+				infopages);
+	printnolog(SUSPEND_IO, SUSPEND_LOW, 0,
+			"Max info pages was %d.\n",
+			maxinfopages);
+	if (buffer_allocs != buffer_frees)
+		printk("Buffer allocs (%d) != buffer frees (%d)",
+				buffer_allocs,
+				buffer_frees);
+}
+
+/*
+ * suspend_end_buffer_io_async
+ *
+ * Description:	Function called by block driver from interrupt context when I/O
+ * 		is completed. This is the reason we use spinlocks in
+ * 		manipulating the io_info lists. 		
+ * 		Nearly the fs/buffer.c version, but we want to mark the page as 
+ * 		done in our own structures too.
+ */
+
+static int suspend_end_bio(struct bio * bio, unsigned int num, int err)
+{
+	struct io_info *io_info = (struct io_info *) bio->bi_private;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&ioinfo_lists_lock, flags);
+	list_move_tail(&io_info->list, &ioinfo_ready_for_cleanup);
+	spin_unlock_irqrestore(&ioinfo_lists_lock, flags);
+	return 0;
+}
+
+/**
+ *	submit - submit BIO request.
+ *	@rw:	READ or WRITE.
+ *	@io_info: IO info structure.
+ *
+ *	Straight from the textbook - allocate and initialize the bio.
+ *	If we're writing, make sure the page is marked as dirty.
+ *	Then submit it and carry on.
+ */
+
+static int submit(int rw, struct io_info * io_info)
+{
+	int error = 0;
+	struct bio * bio = NULL;
+
+	while (!bio) {
+		bio = bio_alloc(GFP_ATOMIC,1);
+		if (!bio) {
+			io_schedule();
+			ioinfo_cleanup_one();
+		}
+	}
+
+	bio->bi_sector = io_info->blocks[0] << (PAGE_SHIFT - 9);
+	bio->bi_bdev = io_info->dev;
+	bio->bi_private = io_info;
+	bio->bi_end_io = suspend_end_bio;
+	io_info->sys_struct = bio;
+
+	if (bio_add_page(bio, io_info->buffer_page, PAGE_SIZE, 0) < PAGE_SIZE) {
+		printk("ERROR: adding page to bio at %ld\n",
+				io_info->blocks[0]);
+		bio_put(bio);
+		return -EFAULT;
+	}
+
+	if (rw == WRITE)
+		bio_set_pages_dirty(bio);
+	submit_bio(rw,bio);
+	return error;
+}
+
+/*
+ * suspend_set_block_size
+ *
+ * Description: Set the blocksize for a bdev. This is a separate function
+ * 		because we have different versions for 2.4 and 2.6.
+ */
+inline int suspend_set_block_size(struct block_device * bdev, int size)
+{
+	return set_blocksize(bdev, size);
+}
+
+inline int suspend_get_block_size(struct block_device * bdev)
+{
+	return SWAP_BLOCKSIZE(bdev);
+}
+
+/*
+ * start_one
+ *
+ * Description:	Prepare and start a read or write operation.
+ * 		Note that we use our own buffer for reading or writing.
+ * 		This simplifies doing readahead and asynchronous writing.
+ * 		We can begin a read without knowing the location into which
+ * 		the data will eventually be placed, and the buffer passed
+ * 		for a write can be reused immediately (essential for the
+ * 		plugins system).
+ * 		Failure? What's that?
+ * Returns:	The io_info struct created.
+ */
+static struct io_info * start_one(int rw, struct submit_params * submit_info)
+{
+	struct io_info * io_info = get_io_info_struct();
+	unsigned long buffer_virt;
+	char * to, * from;
+	struct page * buffer_page;
+	int i;
+
+
+	/* Get our local buffer */
+	printlog(SUSPEND_IO, SUSPEND_HIGH, "Start_IO: [%p]", io_info);
+	while (!(buffer_virt = get_zeroed_page(GFP_ATOMIC))) {
+		RUN_IO;
+		ioinfo_cleanup_one();
+	}
+	buffer_allocs++;
+	printlog(SUSPEND_IO, SUSPEND_HIGH, "[ALLOC BUFFER]->%d",
+			nr_free_pages());
+	buffer_page = virt_to_page(buffer_virt);
+	
+	/* Copy settings to the io_info struct */
+	io_info->data_page = submit_info->page;
+	io_info->buffer_page = buffer_page;
+	io_info->readahead_index = submit_info->readahead_index;
+
+	/* If writing, copy our data. The data is probably in
+	 * lowmem, but we cannot be certain. If there is no
+	 * compression/encryption, we might be passed the
+	 * actual source page's address. */
+	if (rw == WRITE) {
+		set_bit(IO_WRITING, &io_info->flags);
+
+		to = (char *) buffer_virt;
+		from = KMAP_ATOMIC(io_info->data_page);
+		memcpy(to, from, PAGE_SIZE);
+		flush_dcache_page(io_info->data_page);
+		flush_dcache_page(buffer_page);
+		KUNMAP_ATOMIC(io_info->data_page);
+	}
+
+	/* Submit the page */
+	get_page(buffer_page);
+	
+	io_info->dev = submit_info->dev;
+	for (i = 0; i < submit_info->blocks_used; i++)
+		io_info->blocks[i] = submit_info->blocks[i];
+	io_info->blocks_used = submit_info->blocks_used;
+	io_info->block_size = PAGE_SIZE / submit_info->blocks_used;
+
+	if (rw == READ)
+		set_bit(IO_AWAITING_READ, &io_info->flags);
+	else
+		set_bit(IO_AWAITING_WRITE, &io_info->flags);
+
+	printlog(SUSPEND_IO, SUSPEND_HIGH, "-> (PRE BRW) %d\n",
+			nr_free_pages());
+
+ 	submit(rw, io_info);
+	
+	outstanding_io++;
+	if (outstanding_io > max_outstanding_io)
+		max_outstanding_io++;
+	
+	return io_info;
+}
+
+void cleanup_completed_io(void)
+{
+	/*
+	 * We clean up all we can at once so we don't only batch the first lot.
+	 */
+	do { } while (!ioinfo_cleanup_one());
+}
+
+void do_suspend_io(int rw, 
+		struct submit_params * submit_info, int syncio)
+{
+	struct io_info * io_info = start_one(rw, submit_info);
+	if (!io_info) {
+		/* Wait on pages until no more */
+		wait_on_one_page(ERR_PTR(-ENODATA));
+	} else if (syncio) {
+		//finish_all_io();
+		wait_on_one_page(io_info);
+	}
+} 
+
+/* We used to use bread here, but it doesn't correctly handle
+ * blocksize != PAGE_SIZE. Now we create a submit_info to get the data we
+ * want and use our normal routines (synchronously).
+ */
+
+void bdev_page_io(int rw, DEVICE_BLOCK_TYPE bdev, long pos,
+		struct page * page)
+{
+	struct submit_params submit_info;
+
+	submit_info.page = page;
+	submit_info.dev = bdev;
+
+	submit_info.blocks[0] = pos;
+	submit_info.blocks_used = 1;
+	submit_info.readahead_index = -1;
+	do_suspend_io(rw, &submit_info, 1);
+}
+
+void suspend_wait_on_readahead(int readahead_index)
+{
+	int index = readahead_index/(8 * sizeof(unsigned long));
+	int bit = readahead_index - index * 8 * sizeof(unsigned long);
+
+	/* read_ahead_index is the one we want to return */
+	while (!test_bit(bit, &suspend_readahead_flags[index])) {
+		RUN_IO;
+		ioinfo_cleanup_one();
+	}
+
+}
diff -ruN linux-2.6.7/kernel/power/console.c software-suspend-linux-2.6.7-rev10/kernel/power/console.c
--- linux-2.6.7/kernel/power/console.c	2004-05-27 23:16:45.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/power/console.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,55 +0,0 @@
-/*
- * drivers/power/process.c - Functions for saving/restoring console.
- *
- * Originally from swsusp.
- */
-
-#include <linux/vt_kern.h>
-#include <linux/kbd_kern.h>
-#include <linux/console.h>
-#include "power.h"
-
-static int new_loglevel = 10;
-static int orig_loglevel;
-static int orig_fgconsole, orig_kmsg;
-
-int pm_prepare_console(void)
-{
-	orig_loglevel = console_loglevel;
-	console_loglevel = new_loglevel;
-
-#ifdef SUSPEND_CONSOLE
-	acquire_console_sem();
-
-	orig_fgconsole = fg_console;
-
-	if (vc_allocate(SUSPEND_CONSOLE)) {
-	  /* we can't have a free VC for now. Too bad,
-	   * we don't want to mess the screen for now. */
-		release_console_sem();
-		return 1;
-	}
-
-	set_console(SUSPEND_CONSOLE);
-	release_console_sem();
-
-	if (vt_waitactive(SUSPEND_CONSOLE)) {
-		pr_debug("Suspend: Can't switch VCs.");
-		return 1;
-	}
-	orig_kmsg = kmsg_redirect;
-	kmsg_redirect = SUSPEND_CONSOLE;
-#endif
-	return 0;
-}
-
-void pm_restore_console(void)
-{
-	console_loglevel = orig_loglevel;
-#ifdef SUSPEND_CONSOLE
-	acquire_console_sem();
-	set_console(orig_fgconsole);
-	release_console_sem();
-#endif
-	return;
-}
diff -ruN linux-2.6.7/kernel/power/disk.c software-suspend-linux-2.6.7-rev10/kernel/power/disk.c
--- linux-2.6.7/kernel/power/disk.c	2004-05-27 23:16:45.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/power/disk.c	2004-07-08 14:37:07.000000000 +1000
@@ -11,12 +11,13 @@
 #define DEBUG
 
 
-#include <linux/suspend.h>
+#include <linux/suspend1.h>
 #include <linux/syscalls.h>
 #include <linux/reboot.h>
 #include <linux/string.h>
 #include <linux/delay.h>
 #include <linux/fs.h>
+#include <linux/init.h>
 #include "power.h"
 
 
diff -ruN linux-2.6.7/kernel/power/Kconfig software-suspend-linux-2.6.7-rev10/kernel/power/Kconfig
--- linux-2.6.7/kernel/power/Kconfig	2004-05-27 23:16:45.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/power/Kconfig	2004-07-08 14:37:07.000000000 +1000
@@ -22,14 +22,16 @@
 	bool "Software Suspend (EXPERIMENTAL)"
 	depends on EXPERIMENTAL && PM && SWAP
 	---help---
-	  Enable the possibilty of suspendig machine. It doesn't need APM.
+	  Pavel's original version.
+
+	  Enable the possibilty of suspending your machine. It doesn't need APM.
 	  You may suspend your machine by 'swsusp' or 'shutdown -z <time>' 
 	  (patch for sysvinit needed). 
 
-	  It creates an image which is saved in your active swaps. By the next
-	  booting the, pass 'resume=/dev/swappartition' and kernel will 
-	  detect the saved image, restore the memory from
-	  it and then it continues to run as before you've suspended.
+	  It creates an image which is saved in your active swaps. At the next
+	  boot, pass 'resume=/dev/swappartition' and the kernel will 
+	  detect the saved image, restore the memory from disk
+	  and then continue to run as before you suspended.
 	  If you don't want the previous state to continue use the 'noresume'
 	  kernel option. However note that your partitions will be fsck'd and
 	  you must re-mkswap your swap partitions. It does not work with swap
@@ -42,6 +44,141 @@
 
 	  For more information take a look at Documentation/power/swsusp.txt.
 
+menu "Software Suspend 2"
+	depends on EXPERIMENTAL && PM
+
+	config SOFTWARE_SUSPEND2
+	bool
+
+	comment 'Image Storage (you need at least one writer)'
+	
+	config SOFTWARE_SUSPEND_SWAPWRITER
+		bool '   Swap Writer'
+		depends on SWAP
+		select SOFTWARE_SUSPEND2
+		---help---
+		  This option enabled support for storing an image in your
+		  swap space. Swap partitions are supported. Swap file
+		  support is currently broken (16 April 2004).
+
+	config SOFTWARE_SUSPEND_NFSWRITER
+		bool '   NFS Writer'
+		depends on NFSROOT
+		select SOFTWARE_SUSPEND2
+		---help---
+		  This option currently does nothing. The NFS writer is just
+		  beginning to be written.
+
+	config SOFTWARE_SUSPEND_NULLWRITER
+		bool '   Null Writer (For debugging)'
+		select SOFTWARE_SUSPEND2
+		---help---
+		  This is a template, which you can use to develop your
+		  own storage backend for Software Suspend 2.
+
+	if SOFTWARE_SUSPEND2
+		comment 'Page Transformers'
+
+		config SOFTWARE_SUSPEND_LZF_COMPRESSION
+			bool '   LZF image compression'
+			default Y
+			---help---
+			  This option enables compression of pages stored during suspending
+			  to disk, using LZF compression. LZF compression is fast and
+			  still achieves a good compression ratio.
+
+			  You want to say 'Y'.
+
+		config SOFTWARE_SUSPEND_GZIP_COMPRESSION
+			bool '   GZIP image Compression'
+			select ZLIB_DEFLATE
+			select ZLIB_INFLATE
+			---help---
+			  This option enables compression of pages stored during Software Suspend
+			  process. Pages are compressed using the zlib library, with a default
+			  setting (in code) of fastest compression. If your swap device is
+			  significantly slower than your CPU, you may improve the speed of a
+			  suspend/resume cycle by enabling this option.
+		  		
+			  You may also benefit from it if your swap space is small. Note, however,
+			  that since we can't know how big the image will be until we actually
+			  compress it, the algorithm assumes no compression will be achieved and
+			  ensures that your data will fit on disk even if that happens. This means
+			  that more memory will be eaten than probably needs to be. The best
+			  solution to this issue is to increase your swapspace size. We may
+			  implement support for a swap file in future.
+				
+			  This option should be off for most people.
+
+		config SOFTWARE_SUSPEND_NULLTRANSFORMER
+			bool '  Null Page Transformer (For debugging)'
+
+		comment 'General Options'
+
+		config SOFTWARE_SUSPEND_DEBUG
+			bool '   Compile in debugging output'
+			---help---
+			  This option enables the inclusion of debugging info in the software
+			  suspend code. Turning it off will reduce the kernel size but make
+			  debugging suspend & resume issues harder to do.
+		
+			  For normal usage, this option can be turned off.
+
+		config SOFTWARE_SUSPEND_VARIATION_ANALYSIS
+			bool '   Variation Analysis'
+			---help---
+			  This option enables code which allows you to examine the differences
+			  between the contents of memory at 2 points in time (usually before
+			  and after suspending). It is mostly intended for Nigel to use, and
+			  thus the documentation is not wonderful :>.
+
+		config SOFTWARE_SUSPEND2_DUMP
+			bool '   Metadata dump'
+			---help---
+			  This is a temporary option which allows you to dump metadata about
+			  the image to dmesg, rather than resuming from it. Add suspend_dump
+			  to the command line to do this.
+			
+		config SOFTWARE_SUSPEND_KEEP_IMAGE
+			bool '   Allow Keep Image Mode'
+			---help---
+			  This option allows you to keep and image and reuse it. It is intended
+			  __ONLY__ for use with systems where all filesystems are mounted read-
+			  only (kiosks, for example). To use it, compile this option in and boot
+			  normally. Set the KEEP_IMAGE flag in /proc/swsusp and suspend. When you
+			  resume, the image will not be removed. You will be unable to turn
+			  off swap partitions (assuming you are using the swap writer), but future
+			  suspends simply do a power-down. The image can be updated using the
+			  kernel command line parameter suspend_act= to turn off the keep image
+			  bit. Keep image mode is a little less user friendly on purpose - it
+			  should not be used without thought!
+
+		config SOFTWARE_SUSPEND_RELAXED_PROC
+			bool '   Relaxed /proc/swsusp permissions'
+			---help---
+			  This option makes /proc/swsusp entries world-accessible, rather than
+			  root-only. It is intended for systems where security is not a concern.
+			
+			  Networked machines, and particularly those where users are granted
+			  shell access, should say 'N' here!
+
+		config SOFTWARE_SUSPEND_DEFAULT_RESUME2
+			string '   Default resume device name'
+			---help---
+			  You normally need to add a resume2= parameter to your lilo.conf or
+			  equivalent. With this option properly set, the kernel has a value
+			  to default. No damage will be done if the value is invalid.
+
+	endif
+	
+	comment 'Suspend will not be compiled in if no storage method is selected.'
+		depends on !SOFTWARE_SUSPEND2
+	
+endmenu
+
+comment 'Suspend2 depends on EXPERIMENTAL and PM support.'
+	depends on !EXPERIMENTAL || !PM
+
 config PM_DISK
 	bool "Suspend-to-Disk Support"
 	depends on PM && SWAP && X86 && !X86_64
diff -ruN linux-2.6.7/kernel/power/main.c software-suspend-linux-2.6.7-rev10/kernel/power/main.c
--- linux-2.6.7/kernel/power/main.c	2004-05-27 23:16:45.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/power/main.c	2004-07-08 14:37:07.000000000 +1000
@@ -17,7 +17,8 @@
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/pm.h>
-
+#include <linux/cpumask.h>
+#include <asm/semaphore.h>
 
 #include "power.h"
 
diff -ruN linux-2.6.7/kernel/power/Makefile software-suspend-linux-2.6.7-rev10/kernel/power/Makefile
--- linux-2.6.7/kernel/power/Makefile	2004-05-27 23:16:45.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/power/Makefile	2004-07-08 14:37:07.000000000 +1000
@@ -1,5 +1,16 @@
-obj-y				:= main.o process.o console.o pm.o
+obj-y				:= main.o process.o ui.o pm.o utility.o
+obj-$(CONFIG_SOFTWARE_SUSPEND_LZF_COMPRESSION)	+= lzfcompress.o
+obj-$(CONFIG_SOFTWARE_SUSPEND_GZIP_COMPRESSION)	+= gzipcompress.o
+obj-$(CONFIG_SOFTWARE_SUSPEND_NULLTRANSFORMER)	+= nulltransformer.o
+obj-$(CONFIG_SOFTWARE_SUSPEND_NULLWRITER)	+= nullwriter.o
+obj-$(CONFIG_SOFTWARE_SUSPEND_NFSWRITER)	+= nfswriter.o
+obj-$(CONFIG_SOFTWARE_SUSPEND_SWAPWRITER)	+= swapwriter.o block_io.o
+obj-$(CONFIG_SOFTWARE_SUSPEND2) += io.o memory_pool.o pagedir.o prepare_image.o proc.o range.o suspend2.o
 obj-$(CONFIG_SOFTWARE_SUSPEND)	+= swsusp.o
 obj-$(CONFIG_PM_DISK)		+= disk.o pmdisk.o
 
 obj-$(CONFIG_MAGIC_SYSRQ)	+= poweroff.o
+
+ui.c:
+	@(echo -e "\n\n *** It looks like you have not applied the core Software Suspend patch. *** \n\n"; \
+	  exit 1)
diff -ruN linux-2.6.7/kernel/power/pmdisk.c software-suspend-linux-2.6.7-rev10/kernel/power/pmdisk.c
--- linux-2.6.7/kernel/power/pmdisk.c	2004-05-27 23:16:45.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/power/pmdisk.c	2004-07-08 14:37:07.000000000 +1000
@@ -22,7 +22,7 @@
 
 #include <linux/mm.h>
 #include <linux/bio.h>
-#include <linux/suspend.h>
+#include <linux/suspend1.h>
 #include <linux/version.h>
 #include <linux/reboot.h>
 #include <linux/device.h>
diff -ruN linux-2.6.7/kernel/power/process.c software-suspend-linux-2.6.7-rev10/kernel/power/process.c
--- linux-2.6.7/kernel/power/process.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/power/process.c	1970-01-01 10:00:00.000000000 +1000
@@ -1,120 +0,0 @@
-/*
- * drivers/power/process.c - Functions for starting/stopping processes on 
- *                           suspend transitions.
- *
- * Originally from swsusp.
- */
-
-
-#undef DEBUG
-
-#include <linux/smp_lock.h>
-#include <linux/interrupt.h>
-#include <linux/suspend.h>
-#include <linux/module.h>
-
-/* 
- * Timeout for stopping processes
- */
-#define TIMEOUT	(6 * HZ)
-
-
-static inline int freezeable(struct task_struct * p)
-{
-	if ((p == current) || 
-	    (p->flags & PF_NOFREEZE) ||
-	    (p->state == TASK_ZOMBIE) ||
-	    (p->state == TASK_DEAD) ||
-	    (p->state == TASK_STOPPED))
-		return 0;
-	return 1;
-}
-
-/* Refrigerator is place where frozen processes are stored :-). */
-void refrigerator(unsigned long flag)
-{
-	/* Hmm, should we be allowed to suspend when there are realtime
-	   processes around? */
-	long save;
-	save = current->state;
-	current->state = TASK_UNINTERRUPTIBLE;
-	pr_debug("%s entered refrigerator\n", current->comm);
-	printk("=");
-	current->flags &= ~PF_FREEZE;
-
-	spin_lock_irq(&current->sighand->siglock);
-	recalc_sigpending(); /* We sent fake signal, clean it up */
-	spin_unlock_irq(&current->sighand->siglock);
-
-	current->flags |= PF_FROZEN;
-	while (current->flags & PF_FROZEN)
-		schedule();
-	pr_debug("%s left refrigerator\n", current->comm);
-	current->state = save;
-}
-
-/* 0 = success, else # of processes that we failed to stop */
-int freeze_processes(void)
-{
-       int todo;
-       unsigned long start_time;
-	struct task_struct *g, *p;
-	
-	printk( "Stopping tasks: " );
-	start_time = jiffies;
-	do {
-		todo = 0;
-		read_lock(&tasklist_lock);
-		do_each_thread(g, p) {
-			unsigned long flags;
-			if (!freezeable(p))
-				continue;
-			if ((p->flags & PF_FROZEN) ||
-			    (p->state == TASK_STOPPED))
-				continue;
-
-			/* FIXME: smp problem here: we may not access other process' flags
-			   without locking */
-			p->flags |= PF_FREEZE;
-			spin_lock_irqsave(&p->sighand->siglock, flags);
-			signal_wake_up(p, 0);
-			spin_unlock_irqrestore(&p->sighand->siglock, flags);
-			todo++;
-		} while_each_thread(g, p);
-		read_unlock(&tasklist_lock);
-		yield();			/* Yield is okay here */
-		if (time_after(jiffies, start_time + TIMEOUT)) {
-			printk( "\n" );
-			printk(KERN_ERR " stopping tasks failed (%d tasks remaining)\n", todo );
-			return todo;
-		}
-	} while(todo);
-	
-	printk( "|\n" );
-	BUG_ON(in_atomic());
-	return 0;
-}
-
-void thaw_processes(void)
-{
-	struct task_struct *g, *p;
-
-	printk( "Restarting tasks..." );
-	read_lock(&tasklist_lock);
-	do_each_thread(g, p) {
-		if (!freezeable(p))
-			continue;
-		if (p->flags & PF_FROZEN) {
-			p->flags &= ~PF_FROZEN;
-			wake_up_process(p);
-		} else
-			printk(KERN_INFO " Strange, %s not stopped\n", p->comm );
-		wake_up_process(p);
-	} while_each_thread(g, p);
-
-	read_unlock(&tasklist_lock);
-	schedule();
-	printk( " done\n" );
-}
-
-EXPORT_SYMBOL(refrigerator);
diff -ruN linux-2.6.7/kernel/power/swsusp.c software-suspend-linux-2.6.7-rev10/kernel/power/swsusp.c
--- linux-2.6.7/kernel/power/swsusp.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/power/swsusp.c	2004-07-08 14:37:07.000000000 +1000
@@ -38,7 +38,7 @@
 
 #include <linux/module.h>
 #include <linux/mm.h>
-#include <linux/suspend.h>
+#include <linux/suspend1.h>
 #include <linux/smp_lock.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
diff -ruN linux-2.6.7/kernel/sched.c software-suspend-linux-2.6.7-rev10/kernel/sched.c
--- linux-2.6.7/kernel/sched.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/sched.c	2004-07-08 14:37:07.000000000 +1000
@@ -31,7 +31,6 @@
 #include <linux/kernel_stat.h>
 #include <linux/security.h>
 #include <linux/notifier.h>
-#include <linux/suspend.h>
 #include <linux/blkdev.h>
 #include <linux/delay.h>
 #include <linux/smp.h>
@@ -3171,7 +3170,7 @@
 	return list_entry(p->sibling.next,struct task_struct,sibling);
 }
 
-static void show_task(task_t * p)
+void show_task(task_t * p)
 {
 	task_t *relative;
 	unsigned state;
@@ -3555,7 +3554,8 @@
 
 	switch (action) {
 	case CPU_UP_PREPARE:
-		p = kthread_create(migration_thread, hcpu, "migration/%d",cpu);
+		p = kthread_create(migration_thread, hcpu, 0,
+				"migration/%d",cpu);
 		if (IS_ERR(p))
 			return NOTIFY_BAD;
 		kthread_bind(p, cpu);
diff -ruN linux-2.6.7/kernel/softirq.c software-suspend-linux-2.6.7-rev10/kernel/softirq.c
--- linux-2.6.7/kernel/softirq.c	2004-05-19 22:10:48.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/softirq.c	2004-07-08 14:37:07.000000000 +1000
@@ -425,7 +425,7 @@
 	case CPU_UP_PREPARE:
 		BUG_ON(per_cpu(tasklet_vec, hotcpu).list);
 		BUG_ON(per_cpu(tasklet_hi_vec, hotcpu).list);
-		p = kthread_create(ksoftirqd, hcpu, "ksoftirqd/%d", hotcpu);
+		p = kthread_create(ksoftirqd, hcpu, 0, "ksoftirqd/%d", hotcpu);
 		if (IS_ERR(p)) {
 			printk("ksoftirqd for %i failed\n", hotcpu);
 			return NOTIFY_BAD;
diff -ruN linux-2.6.7/kernel/stop_machine.c software-suspend-linux-2.6.7-rev10/kernel/stop_machine.c
--- linux-2.6.7/kernel/stop_machine.c	2004-05-19 22:10:48.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/stop_machine.c	2004-07-08 14:37:07.000000000 +1000
@@ -174,7 +174,7 @@
 	if (cpu == NR_CPUS)
 		cpu = smp_processor_id();
 
-	p = kthread_create(do_stop, &smdata, "kstopmachine");
+	p = kthread_create(do_stop, &smdata, 0, "kstopmachine");
 	if (!IS_ERR(p)) {
 		kthread_bind(p, cpu);
 		wake_up_process(p);
diff -ruN linux-2.6.7/kernel/sys.c software-suspend-linux-2.6.7-rev10/kernel/sys.c
--- linux-2.6.7/kernel/sys.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/sys.c	2004-07-08 14:37:07.000000000 +1000
@@ -503,10 +503,14 @@
 		machine_restart(buffer);
 		break;
 
-#ifdef CONFIG_SOFTWARE_SUSPEND
+#ifdef CONFIG_SOFTWARE_SUSPEND2
 	case LINUX_REBOOT_CMD_SW_SUSPEND:
 		{
-			int ret = software_suspend();
+			int ret = -EINVAL;
+			if (!(software_suspend_state & SOFTWARE_SUSPEND_DISABLED)) {
+				software_suspend_pending();
+				ret = 0;
+			}
 			unlock_kernel();
 			return ret;
 		}
diff -ruN linux-2.6.7/kernel/workqueue.c software-suspend-linux-2.6.7-rev10/kernel/workqueue.c
--- linux-2.6.7/kernel/workqueue.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/kernel/workqueue.c	2004-07-08 14:37:07.000000000 +1000
@@ -25,6 +25,7 @@
 #include <linux/cpu.h>
 #include <linux/notifier.h>
 #include <linux/kthread.h>
+#include <linux/suspend.h>
 
 /*
  * The per-CPU workqueue (if single thread, we always use cpu 0's).
@@ -186,8 +187,6 @@
 	struct k_sigaction sa;
 	sigset_t blocked;
 
-	current->flags |= PF_NOFREEZE;
-
 	set_user_nice(current, -10);
 
 	/* Block and flush all signals */
@@ -208,6 +207,8 @@
 			schedule();
 		else
 			__set_current_state(TASK_RUNNING);
+		if (current->flags & PF_FREEZE)
+			refrigerator(PF_FREEZE);
 		remove_wait_queue(&cwq->more_work, &wait);
 
 		if (!list_empty(&cwq->worklist))
@@ -277,7 +278,8 @@
 }
 
 static struct task_struct *create_workqueue_thread(struct workqueue_struct *wq,
-						   int cpu)
+						   int cpu,
+						   unsigned long freezer_flags)
 {
 	struct cpu_workqueue_struct *cwq = wq->cpu_wq + cpu;
 	struct task_struct *p;
@@ -292,9 +294,11 @@
 	init_waitqueue_head(&cwq->work_done);
 
 	if (is_single_threaded(wq))
-		p = kthread_create(worker_thread, cwq, "%s", wq->name);
+		p = kthread_create(worker_thread, cwq, freezer_flags, 
+				"%s", wq->name);
 	else
-		p = kthread_create(worker_thread, cwq, "%s/%d", wq->name, cpu);
+		p = kthread_create(worker_thread, cwq, freezer_flags,
+				"%s/%d", wq->name, cpu);
 	if (IS_ERR(p))
 		return NULL;
 	cwq->thread = p;
@@ -302,7 +306,8 @@
 }
 
 struct workqueue_struct *__create_workqueue(const char *name,
-					    int singlethread)
+					    int singlethread,
+					    unsigned long freezer_flags)
 {
 	int cpu, destroy = 0;
 	struct workqueue_struct *wq;
@@ -320,7 +325,7 @@
 	lock_cpu_hotplug();
 	if (singlethread) {
 		INIT_LIST_HEAD(&wq->list);
-		p = create_workqueue_thread(wq, 0);
+		p = create_workqueue_thread(wq, 0, freezer_flags);
 		if (!p)
 			destroy = 1;
 		else
@@ -330,7 +335,7 @@
 		list_add(&wq->list, &workqueues);
 		spin_unlock(&workqueue_lock);
 		for_each_online_cpu(cpu) {
-			p = create_workqueue_thread(wq, cpu);
+			p = create_workqueue_thread(wq, cpu, freezer_flags);
 			if (p) {
 				kthread_bind(p, cpu);
 				wake_up_process(p);
@@ -493,7 +498,7 @@
 void init_workqueues(void)
 {
 	hotcpu_notifier(workqueue_cpu_callback, 0);
-	keventd_wq = create_workqueue("events");
+	keventd_wq = create_workqueue("events", 0);
 	BUG_ON(!keventd_wq);
 }
 
diff -ruN linux-2.6.7/mm/bootmem.c software-suspend-linux-2.6.7-rev10/mm/bootmem.c
--- linux-2.6.7/mm/bootmem.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/mm/bootmem.c	2004-07-08 14:37:07.000000000 +1000
@@ -270,6 +270,7 @@
 				if (v & m) {
 					count++;
 					ClearPageReserved(page);
+					ClearPageNosave(page);
 					set_page_count(page, 1);
 					__free_page(page);
 				}
@@ -290,6 +291,7 @@
 	for (i = 0; i < ((bdata->node_low_pfn-(bdata->node_boot_start >> PAGE_SHIFT))/8 + PAGE_SIZE-1)/PAGE_SIZE; i++,page++) {
 		count++;
 		ClearPageReserved(page);
+		ClearPageNosave(page);
 		set_page_count(page, 1);
 		__free_page(page);
 	}
diff -ruN linux-2.6.7/mm/highmem.c software-suspend-linux-2.6.7-rev10/mm/highmem.c
--- linux-2.6.7/mm/highmem.c	2004-03-16 09:20:22.000000000 +1100
+++ software-suspend-linux-2.6.7-rev10/mm/highmem.c	2004-07-08 14:37:07.000000000 +1000
@@ -95,7 +95,12 @@
 
 		set_page_address(page, NULL);
 	}
-	flush_tlb_kernel_range(PKMAP_ADDR(0), PKMAP_ADDR(LAST_PKMAP));
+#ifdef CONFIG_PM
+	if (software_suspend_state & SOFTWARE_SUSPEND_FREEZE_SMP)
+		__flush_tlb();
+	else
+#endif
+		flush_tlb_kernel_range(PKMAP_ADDR(0), PKMAP_ADDR(LAST_PKMAP));
 }
 
 static inline unsigned long map_new_virtual(struct page *page)
diff -ruN linux-2.6.7/mm/oom_kill.c software-suspend-linux-2.6.7-rev10/mm/oom_kill.c
--- linux-2.6.7/mm/oom_kill.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/mm/oom_kill.c	2004-07-08 14:37:07.000000000 +1000
@@ -20,6 +20,7 @@
 #include <linux/swap.h>
 #include <linux/timex.h>
 #include <linux/jiffies.h>
+#include <linux/suspend.h>
 
 /* #define DEBUG */
 
@@ -236,6 +237,10 @@
 	if (nr_swap_pages > 0)
 		return;
 
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (software_suspend_state & SOFTWARE_SUSPEND_RUNNING)
+		return;
+#endif
 	spin_lock(&oom_lock);
 	now = jiffies;
 	since = now - last;
diff -ruN linux-2.6.7/mm/page_alloc.c software-suspend-linux-2.6.7-rev10/mm/page_alloc.c
--- linux-2.6.7/mm/page_alloc.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/mm/page_alloc.c	2004-07-08 14:37:07.000000000 +1000
@@ -42,6 +42,12 @@
 int numnodes = 1;
 int sysctl_lower_zone_protection = 0;
 
+#ifdef CONFIG_PM
+char pcp_lists_enabled = 1;
+#else
+#define pcp_lists_enabled (1)
+#endif
+
 EXPORT_SYMBOL(totalram_pages);
 EXPORT_SYMBOL(nr_swap_pages);
 
@@ -282,6 +288,13 @@
 	mod_page_state(pgfree, 1 << order);
 	for (i = 0 ; i < (1 << order) ; ++i)
 		free_pages_check(__FUNCTION__, page + i);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (unlikely((software_suspend_state & SOFTWARE_SUSPEND_USE_MEMORY_POOL)
+			&& (!PageHighMem(page)))) {
+		free_suspend_pool_pages(page, order);
+		return;
+	}
+#endif
 	list_add(&page->lru, &list);
 	kernel_map_pages(page, 1<<order, 0);
 	free_pages_bulk(page_zone(page), 1, &list, order);
@@ -459,6 +472,35 @@
 	__drain_pages(smp_processor_id());
 	local_irq_restore(flags);	
 }
+
+#ifdef CONFIG_SMP
+static void __smp_drain_local_pages(void * data)
+{
+	drain_local_pages();
+}
+
+void smp_drain_local_pages(void)
+{
+	smp_call_function(__smp_drain_local_pages, NULL, 0, 1);
+	drain_local_pages();
+}
+#else
+void smp_drain_local_pages(void)
+{
+	drain_local_pages();
+}
+#endif
+
+void disable_pcp_lists(void)
+{
+	pcp_lists_enabled = 0;
+	smp_drain_local_pages();
+}
+
+void enable_pcp_lists(void)
+{
+	pcp_lists_enabled = 1;
+}
 #endif /* CONFIG_PM */
 
 static void zone_statistics(struct zonelist *zonelist, struct zone *z)
@@ -497,6 +539,11 @@
 	struct per_cpu_pages *pcp;
 	unsigned long flags;
 
+	if (!pcp_lists_enabled) {
+		__free_pages_ok(page, 0);
+		return;
+	}
+	
 	kernel_map_pages(page, 1, 0);
 	inc_page_state(pgfree);
 	free_pages_check(__FUNCTION__, page);
@@ -533,7 +580,7 @@
 	struct page *page = NULL;
 	int cold = !!(gfp_flags & __GFP_COLD);
 
-	if (order == 0) {
+	if ((order == 0) && (pcp_lists_enabled)) {
 		struct per_cpu_pages *pcp;
 
 		pcp = &zone->pageset[get_cpu()].pcp[cold];
@@ -596,6 +643,22 @@
 	int alloc_type;
 	int do_retry;
 
+#if CONFIG_SOFTWARE_SUSPEND2
+	if (unlikely(software_suspend_state & SOFTWARE_SUSPEND_USE_MEMORY_POOL)) {
+		/*
+		 * When pool enabled, processes get allocations
+		 * from a special pool so the image size doesn't
+		 * vary (all the pages in the pool are saved, 
+		 * used or not).
+		 *
+		 * The only process that should be running is
+		 * suspend, so the demand should be very
+		 * predicatable.
+		 */
+		return get_suspend_pool_page(gfp_mask, order);
+	}
+#endif
+
 	might_sleep_if(wait);
 
 	zones = zonelist->zones;  /* the list of zones suitable for gfp_mask */
diff -ruN linux-2.6.7/mm/page-writeback.c software-suspend-linux-2.6.7-rev10/mm/page-writeback.c
--- linux-2.6.7/mm/page-writeback.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/mm/page-writeback.c	2004-07-08 14:37:07.000000000 +1000
@@ -29,6 +29,7 @@
 #include <linux/sysctl.h>
 #include <linux/cpu.h>
 #include <linux/syscalls.h>
+#include <linux/suspend.h>
 
 /*
  * The maximum number of pages to writeout in a single bdflush/kupdate
@@ -369,6 +370,13 @@
 		.for_kupdate	= 1,
 	};
 
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (software_suspend_state & SOFTWARE_SUSPEND_RUNNING) {
+		start_jif = jiffies;
+		next_jif = start_jif + (dirty_writeback_centisecs * HZ) / 100;
+		goto out;
+	}
+#endif
 	sync_supers();
 
 	get_writeback_state(&wbs);
@@ -389,6 +397,9 @@
 		}
 		nr_to_write -= MAX_WRITEBACK_PAGES - wbc.nr_to_write;
 	}
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+out:
+#endif
 	if (time_before(next_jif, jiffies + HZ))
 		next_jif = jiffies + HZ;
 	if (dirty_writeback_centisecs)
diff -ruN linux-2.6.7/mm/pdflush.c software-suspend-linux-2.6.7-rev10/mm/pdflush.c
--- linux-2.6.7/mm/pdflush.c	2004-05-19 22:10:48.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/mm/pdflush.c	2004-07-08 14:37:07.000000000 +1000
@@ -215,7 +215,7 @@
 
 static void start_one_pdflush_thread(void)
 {
-	kthread_run(pdflush, NULL, "pdflush");
+	kthread_run(pdflush, NULL, 0, "pdflush");
 }
 
 static int __init pdflush_init(void)
diff -ruN linux-2.6.7/mm/slab.c software-suspend-linux-2.6.7-rev10/mm/slab.c
--- linux-2.6.7/mm/slab.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/mm/slab.c	2004-07-08 14:37:07.000000000 +1000
@@ -850,11 +850,23 @@
 	flags |= cachep->gfpflags;
 	if (likely(nodeid == -1)) {
 		addr = (void*)__get_free_pages(flags, cachep->gfporder);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		if (unlikely((!addr) && (current->pid == suspend_task))) {
+			extern unsigned long get_grabbed_pages(int order);
+			addr = (void *) get_grabbed_pages(0);
+		}
+#endif
 		if (!addr)
 			return NULL;
 		page = virt_to_page(addr);
 	} else {
 		page = alloc_pages_node(nodeid, flags, cachep->gfporder);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		if (unlikely((!page) && (current->pid == suspend_task))) {
+			extern unsigned long get_grabbed_pages(int order);
+			page = virt_to_page(get_grabbed_pages(0));
+		}
+#endif
 		if (!page)
 			return NULL;
 		addr = page_address(page);
diff -ruN linux-2.6.7/mm/swapfile.c software-suspend-linux-2.6.7-rev10/mm/swapfile.c
--- linux-2.6.7/mm/swapfile.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/mm/swapfile.c	2004-07-08 14:37:07.000000000 +1000
@@ -17,6 +17,8 @@
 #include <linux/namei.h>
 #include <linux/shm.h>
 #include <linux/blkdev.h>
+#include <linux/suspend.h>
+#include <linux/suspend-debug.h>
 #include <linux/writeback.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
@@ -192,6 +194,8 @@
 	}
 out:
 	swap_list_unlock();
+	if (suspend_task)
+		printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 1, "[Get SWAP %lx]", swp_offset(entry));
 	return entry;
 }
 
@@ -269,6 +273,8 @@
 
 	p = swap_info_get(entry);
 	if (p) {
+		if (suspend_task)
+			printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 1, "[Free SWAP %lx]", entry.val);
 		swap_entry_free(p, swp_offset(entry));
 		swap_info_put(p);
 	}
diff -ruN linux-2.6.7/net/bluetooth/rfcomm/core.c software-suspend-linux-2.6.7-rev10/net/bluetooth/rfcomm/core.c
--- linux-2.6.7/net/bluetooth/rfcomm/core.c	2004-06-18 12:44:22.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/net/bluetooth/rfcomm/core.c	2004-07-08 14:37:07.000000000 +1000
@@ -1738,6 +1738,9 @@
 			schedule();
 		}
 
+		if (current->flags & PF_FREEZE)
+			refrigerator(PF_FREEZE);
+
 		/* Process stuff */
 		clear_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event);
 		rfcomm_process_sessions();
diff -ruN linux-2.6.7/net/sunrpc/svcsock.c software-suspend-linux-2.6.7-rev10/net/sunrpc/svcsock.c
--- linux-2.6.7/net/sunrpc/svcsock.c	2004-06-18 12:44:23.000000000 +1000
+++ software-suspend-linux-2.6.7-rev10/net/sunrpc/svcsock.c	2004-07-08 14:37:07.000000000 +1000
@@ -1193,6 +1193,8 @@
 	arg->len = (pages-1)*PAGE_SIZE;
 	arg->tail[0].iov_len = 0;
 	
+	if (current->flags & PF_FREEZE)
+		refrigerator(PF_FREEZE);
 	if (signalled())
 		return -EINTR;
 
